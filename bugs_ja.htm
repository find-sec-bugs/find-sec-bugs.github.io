<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>Bug Patterns - Find Security Bugs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">


    <link rel="shortcut icon" href="images/favicon.png">
    <link href="//fonts.googleapis.com/css?family=Squada+One" rel="stylesheet" type="text/css"/>

    <link href="css/bootstrap.css" rel="stylesheet" media="screen">
    <link href="css/font-awesome.css" rel="stylesheet" media="screen">
    <link href="css/fsb-custom-theme.css" rel="stylesheet" media="screen">
    <link href="css/agency.css" rel="stylesheet" media="screen">
    <link href="css/prism.css" rel="stylesheet" media="screen">

    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>


<!--<div class="navbar navbar-default navbar-fixed-top">-->

<div class="navbar navbar-expand-sm fixed-top navbar-dark bg-primary">
    <div class="container">

        <a class="navbar-brand" href="/">{<i class="fa fa-bug"></i>}<span style="display:none">Find Security Bugs</span></a>

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div id="navbarResponsive" class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li class=''><a class="nav-link" href="/">Home</a></li>
                <li class="dropdown ">
                    <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">How To <span class="caret"></span></a>
                    <ul class="dropdown-menu" role="menu">
                        <li class="dropdown-header">Use the plugin with..</li>
                        <li><a class="dropdown-item" href="tutorials.htm#Maven">Maven</a></li>
                        <li><a class="dropdown-item" href="tutorials.htm#Eclipse">Eclipse</a></li>
                        <li><a class="dropdown-item" href="tutorials.htm#NetBeans">NetBeans</a></li>
                        <li><a class="dropdown-item" href="tutorials.htm#IntelliJ">IntelliJ</a></li>
                        <li><a class="dropdown-item" href="tutorials.htm#Jenkins">Jenkins</a></li>
                        <li><a class="dropdown-item" href="tutorials.htm#Sonar">Sonar</a></li>
                        <li class="divider"></li>
                        <li class="dropdown-header">Knowledge base</li>
                        <li><a class="dropdown-item" href="security.htm">Getting started in security</a></li>
                    </ul>
                </li>
                <li class='active'><a class="nav-link" href="bugs.htm">Bug Patterns</a></li>
                <li class=''><a class="nav-link" href="download.htm">Download</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right ml-auto">
                <li class=''><a class="nav-link" href="license.htm">License</a></li>
            </ul>
        </div><!--/.nav-collapse -->
    </div>
</div>

<br/><br/>


<div class="container">
    <div class="jumbotron jumbotron-ad hidden-print">

        <h1><i class="fa fa-crosshairs"></i>&nbsp; Bugs Patterns</h1>

        <p>The complete list of descriptions given when FindBugs identify potential weaknesses.</p>

    </div>
</div>

<div class="container">



    <div class="row">
        <div class="col-md-11" id="mainCol">


            <h2>Table of Contents</h2>

            <p>
                <a class="btn btn-primary" data-toggle="collapse" href="#collapseExample" aria-expanded="false" aria-controls="collapseExample">
                    Display / Hide
                </a>
            </p>
            <div class="collapse" id="collapseExample">
                <div class="card card-block">

                    <ul>
                        
                        <li><a href="#PREDICTABLE_RANDOM">
                            予測可能な擬似乱数生成器 (PREDICTABLE_RANDOM)
                        </a></li>
                        
                        <li><a href="#PREDICTABLE_RANDOM_SCALA">
                            予測可能な擬似乱数生成器 (Scala) (PREDICTABLE_RANDOM_SCALA)
                        </a></li>
                        
                        <li><a href="#SERVLET_PARAMETER">
                            信頼できないサーブレットパラメーター (SERVLET_PARAMETER)
                        </a></li>
                        
                        <li><a href="#SERVLET_CONTENT_TYPE">
                            信頼できない Content-Type ヘッダー (SERVLET_CONTENT_TYPE)
                        </a></li>
                        
                        <li><a href="#SERVLET_SERVER_NAME">
                            信頼できない Host ヘッダー (SERVLET_SERVER_NAME)
                        </a></li>
                        
                        <li><a href="#SERVLET_SESSION_ID">
                            信頼できないセッション Cookie の値 (SERVLET_SESSION_ID)
                        </a></li>
                        
                        <li><a href="#SERVLET_QUERY_STRING">
                            信頼できないクエリー文字列 (SERVLET_QUERY_STRING)
                        </a></li>
                        
                        <li><a href="#SERVLET_HEADER">
                            信頼できない HTTP ヘッダー (SERVLET_HEADER)
                        </a></li>
                        
                        <li><a href="#SERVLET_HEADER_REFERER">
                            信頼できない Referer ヘッダー (SERVLET_HEADER_REFERER)
                        </a></li>
                        
                        <li><a href="#SERVLET_HEADER_USER_AGENT">
                            信頼できない User-Agent ヘッダー (SERVLET_HEADER_USER_AGENT)
                        </a></li>
                        
                        <li><a href="#COOKIE_USAGE">
                             Cookie 内に機密データの可能性 (COOKIE_USAGE)
                        </a></li>
                        
                        <li><a href="#PATH_TRAVERSAL_IN">
                            潜在的なパストラバーサル (ファイル読み出し) (PATH_TRAVERSAL_IN)
                        </a></li>
                        
                        <li><a href="#PATH_TRAVERSAL_OUT">
                            潜在的なパストラバーサル (ファイル書き込み) (PATH_TRAVERSAL_OUT)
                        </a></li>
                        
                        <li><a href="#SCALA_PATH_TRAVERSAL_IN">
                            Scala API を使用した潜在的なパストラバーサル (ファイル読み出し) (SCALA_PATH_TRAVERSAL_IN)
                        </a></li>
                        
                        <li><a href="#COMMAND_INJECTION">
                            潜在的なコマンドインジェクション (COMMAND_INJECTION)
                        </a></li>
                        
                        <li><a href="#SCALA_COMMAND_INJECTION">
                            潜在的なコマンドインジェクション (Scala) (SCALA_COMMAND_INJECTION)
                        </a></li>
                        
                        <li><a href="#WEAK_FILENAMEUTILS">
                            FilenameUtils は NULL バイトをフィルタリングしない (WEAK_FILENAMEUTILS)
                        </a></li>
                        
                        <li><a href="#WEAK_TRUST_MANAGER">
                            任意の証明書を受け入れる TrustManager (WEAK_TRUST_MANAGER)
                        </a></li>
                        
                        <li><a href="#WEAK_HOSTNAME_VERIFIER">
                            任意の署名付き証明書を受け入れる HostnameVerifier (WEAK_HOSTNAME_VERIFIER)
                        </a></li>
                        
                        <li><a href="#JAXWS_ENDPOINT">
                            JAX-WS SOAP エンドポイントを発見 (JAXWS_ENDPOINT)
                        </a></li>
                        
                        <li><a href="#JAXRS_ENDPOINT">
                            JAX-RS REST エンドポイントを発見 (JAXRS_ENDPOINT)
                        </a></li>
                        
                        <li><a href="#TAPESTRY_ENDPOINT">
                            Tapestry ページを発見 (TAPESTRY_ENDPOINT)
                        </a></li>
                        
                        <li><a href="#WICKET_ENDPOINT">
                            Wicket ページを発見 (WICKET_ENDPOINT)
                        </a></li>
                        
                        <li><a href="#WEAK_MESSAGE_DIGEST_MD5">
                            MD2，MD4，MD5 は弱いハッシュ関数 (WEAK_MESSAGE_DIGEST_MD5)
                        </a></li>
                        
                        <li><a href="#WEAK_MESSAGE_DIGEST_SHA1">
                            SHA-1 は弱いハッシュ関数 (WEAK_MESSAGE_DIGEST_SHA1)
                        </a></li>
                        
                        <li><a href="#DEFAULT_HTTP_CLIENT">
                            デフォルトのコンストラクターを持つ DefaultHttpClient は TLS 1.2 と互換性がない (DEFAULT_HTTP_CLIENT)
                        </a></li>
                        
                        <li><a href="#SSL_CONTEXT">
                            弱い SSLContext (SSL_CONTEXT)
                        </a></li>
                        
                        <li><a href="#CUSTOM_MESSAGE_DIGEST">
                            独自メッセージダイジェスト (CUSTOM_MESSAGE_DIGEST)
                        </a></li>
                        
                        <li><a href="#FILE_UPLOAD_FILENAME">
                            汚染されたファイル名の読み取り (FILE_UPLOAD_FILENAME)
                        </a></li>
                        
                        <li><a href="#REDOS">
                            正規表現による DoS (ReDoS) (REDOS)
                        </a></li>
                        
                        <li><a href="#XXE_XMLSTREAMREADER">
                            XXE に脆弱な XML 解析 (XMLStreamReader) (XXE_XMLSTREAMREADER)
                        </a></li>
                        
                        <li><a href="#XXE_XPATH">
                            XXE に脆弱な XML 解析 (XPathExpression) (XXE_XPATH)
                        </a></li>
                        
                        <li><a href="#XXE_SAXPARSER">
                            XXE に脆弱な XML 解析 (SAXParser) (XXE_SAXPARSER)
                        </a></li>
                        
                        <li><a href="#XXE_XMLREADER">
                            XXE に脆弱な XML 解析 (XMLReader) (XXE_XMLREADER)
                        </a></li>
                        
                        <li><a href="#XXE_DOCUMENT">
                            XXE に脆弱な XML 解析 (DocumentBuilder) (XXE_DOCUMENT)
                        </a></li>
                        
                        <li><a href="#XXE_DTD_TRANSFORM_FACTORY">
                            XXE に脆弱な XML 解析 (TransformerFactory) (XXE_DTD_TRANSFORM_FACTORY)
                        </a></li>
                        
                        <li><a href="#XXE_XSLT_TRANSFORM_FACTORY">
                            XXE に脆弱な XSLT 解析 (TransformerFactory) (XXE_XSLT_TRANSFORM_FACTORY)
                        </a></li>
                        
                        <li><a href="#XPATH_INJECTION">
                            潜在的な XPath インジェクション (XPATH_INJECTION)
                        </a></li>
                        
                        <li><a href="#STRUTS1_ENDPOINT">
                            Struts 1 アクション を発見 (STRUTS1_ENDPOINT)
                        </a></li>
                        
                        <li><a href="#STRUTS2_ENDPOINT">
                            Struts 2 のエンドポイントを発見 (STRUTS2_ENDPOINT)
                        </a></li>
                        
                        <li><a href="#SPRING_ENDPOINT">
                            Spring のエンドポイントを発見 (SPRING_ENDPOINT)
                        </a></li>
                        
                        <li><a href="#SPRING_CSRF_PROTECTION_DISABLED">
                            Spring CSRF 保護の無効化 (SPRING_CSRF_PROTECTION_DISABLED)
                        </a></li>
                        
                        <li><a href="#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING">
                            Spring の制限のない RequestMapping による CSRF (SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING)
                        </a></li>
                        
                        <li><a href="#CUSTOM_INJECTION">
                            潜在的インジェクション (独自) (CUSTOM_INJECTION)
                        </a></li>
                        
                        <li><a href="#SQL_INJECTION">
                            潜在的な SQL インジェクション (SQL_INJECTION)
                        </a></li>
                        
                        <li><a href="#SQL_INJECTION_TURBINE">
                            Turbine による潜在的な SQL インジェクション (SQL_INJECTION_TURBINE)
                        </a></li>
                        
                        <li><a href="#SQL_INJECTION_HIBERNATE">
                            潜在的な SQL/HQL インジェクション (Hibernate) (SQL_INJECTION_HIBERNATE)
                        </a></li>
                        
                        <li><a href="#SQL_INJECTION_JDO">
                            潜在的な SQL/JDOQL インジェクション (JDO) (SQL_INJECTION_JDO)
                        </a></li>
                        
                        <li><a href="#SQL_INJECTION_JPA">
                            潜在的な SQL/JPQL インジェクション (JPA) (SQL_INJECTION_JPA)
                        </a></li>
                        
                        <li><a href="#SQL_INJECTION_SPRING_JDBC">
                            潜在的な JDBC インジェクション (Spring JDBC) (SQL_INJECTION_SPRING_JDBC)
                        </a></li>
                        
                        <li><a href="#SQL_INJECTION_JDBC">
                            潜在的な JDBC インジェクション (SQL_INJECTION_JDBC)
                        </a></li>
                        
                        <li><a href="#SCALA_SQL_INJECTION_SLICK">
                            潜在的な Scala Slick インジェクション (SCALA_SQL_INJECTION_SLICK)
                        </a></li>
                        
                        <li><a href="#SCALA_SQL_INJECTION_ANORM">
                            潜在的な Scala Anorm インジェクション (SCALA_SQL_INJECTION_ANORM)
                        </a></li>
                        
                        <li><a href="#SQL_INJECTION_ANDROID">
                            潜在的な Android SQL インジェクション (SQL_INJECTION_ANDROID)
                        </a></li>
                        
                        <li><a href="#LDAP_INJECTION">
                            潜在的な LDAP インジェクション (LDAP_INJECTION)
                        </a></li>
                        
                        <li><a href="#SCRIPT_ENGINE_INJECTION">
                            スクリプトエンジン使用時の潜在的なコードインジェクション (SCRIPT_ENGINE_INJECTION)
                        </a></li>
                        
                        <li><a href="#SPEL_INJECTION">
                            Spring 式使用時の潜在的なコードインジェクション (SPEL_INJECTION)
                        </a></li>
                        
                        <li><a href="#EL_INJECTION">
                            式言語 (EL) 使用時の潜在的なコードインジェクション (EL_INJECTION)
                        </a></li>
                        
                        <li><a href="#SEAM_LOG_INJECTION">
                            Seam ロギング呼び出しでの潜在的なコードインジェクション (SEAM_LOG_INJECTION)
                        </a></li>
                        
                        <li><a href="#OGNL_INJECTION">
                            OGNL 式使用時の潜在的なコードインジェクション (OGNL_INJECTION)
                        </a></li>
                        
                        <li><a href="#HTTP_RESPONSE_SPLITTING">
                            潜在的な HTTP レスポンス分割 (HTTP_RESPONSE_SPLITTING)
                        </a></li>
                        
                        <li><a href="#CRLF_INJECTION_LOGS">
                            ログの潜在的な CRLF インジェクション (CRLF_INJECTION_LOGS)
                        </a></li>
                        
                        <li><a href="#EXTERNAL_CONFIG_CONTROL">
                            潜在的な構成の外部制御 (EXTERNAL_CONFIG_CONTROL)
                        </a></li>
                        
                        <li><a href="#BAD_HEXA_CONVERSION">
                            不正な16進数の連結 (BAD_HEXA_CONVERSION)
                        </a></li>
                        
                        <li><a href="#HAZELCAST_SYMMETRIC_ENCRYPTION">
                            Hazelcast 対称暗号 (HAZELCAST_SYMMETRIC_ENCRYPTION)
                        </a></li>
                        
                        <li><a href="#NULL_CIPHER">
                            NullCipher は安全でない (NULL_CIPHER)
                        </a></li>
                        
                        <li><a href="#UNENCRYPTED_SOCKET">
                            暗号化されていないソケット (UNENCRYPTED_SOCKET)
                        </a></li>
                        
                        <li><a href="#UNENCRYPTED_SERVER_SOCKET">
                            暗号化されていないサーバーソケット (UNENCRYPTED_SERVER_SOCKET)
                        </a></li>
                        
                        <li><a href="#DES_USAGE">
                            DES は安全でない (DES_USAGE)
                        </a></li>
                        
                        <li><a href="#TDES_USAGE">
                            DESede は安全でない (TDES_USAGE)
                        </a></li>
                        
                        <li><a href="#RSA_NO_PADDING">
                            パディングなしの RSA 暗号は安全でない (RSA_NO_PADDING)
                        </a></li>
                        
                        <li><a href="#HARD_CODE_PASSWORD">
                            ハードコードされたパスワード (HARD_CODE_PASSWORD)
                        </a></li>
                        
                        <li><a href="#HARD_CODE_KEY">
                            ハードコードされた鍵 (HARD_CODE_KEY)
                        </a></li>
                        
                        <li><a href="#UNSAFE_HASH_EQUALS">
                            安全でないハッシュの比較 (UNSAFE_HASH_EQUALS)
                        </a></li>
                        
                        <li><a href="#STRUTS_FORM_VALIDATION">
                            入力検証がない Struts フォーム (STRUTS_FORM_VALIDATION)
                        </a></li>
                        
                        <li><a href="#XSS_REQUEST_WRAPPER">
                            XSSRequestWrapper は弱い XSS 保護 (XSS_REQUEST_WRAPPER)
                        </a></li>
                        
                        <li><a href="#BLOWFISH_KEY_SIZE">
                            短い鍵での Blowfish の使用 (BLOWFISH_KEY_SIZE)
                        </a></li>
                        
                        <li><a href="#RSA_KEY_SIZE">
                            短い鍵長での RSA の使用 (RSA_KEY_SIZE)
                        </a></li>
                        
                        <li><a href="#UNVALIDATED_REDIRECT">
                            未検証のリダイレクト (UNVALIDATED_REDIRECT)
                        </a></li>
                        
                        <li><a href="#PLAY_UNVALIDATED_REDIRECT">
                            未検証のリダイレクト (Play Framework) (PLAY_UNVALIDATED_REDIRECT)
                        </a></li>
                        
                        <li><a href="#SPRING_UNVALIDATED_REDIRECT">
                            未検証のリダイレクト (Spring アプリケーション) (SPRING_UNVALIDATED_REDIRECT)
                        </a></li>
                        
                        <li><a href="#ENTITY_LEAK">
                            予期しないプロパティ漏洩 (ENTITY_LEAK)
                        </a></li>
                        
                        <li><a href="#ENTITY_MASS_ASSIGNMENT">
                            一括割り当て (ENTITY_MASS_ASSIGNMENT)
                        </a></li>
                        
                        <li><a href="#JSP_INCLUDE">
                            動的 JSP インクルード (JSP_INCLUDE)
                        </a></li>
                        
                        <li><a href="#JSP_SPRING_EVAL">
                            Spring 式の動的変数 (JSP_SPRING_EVAL)
                        </a></li>
                        
                        <li><a href="#JSP_JSTL_OUT">
                            特別な XML 文字のエスケープが無効 (JSP_JSTL_OUT)
                        </a></li>
                        
                        <li><a href="#XSS_JSP_PRINT">
                            JSP 内の潜在的な XSS (XSS_JSP_PRINT)
                        </a></li>
                        
                        <li><a href="#XSS_SERVLET">
                            サーブレット内の潜在的な XSS (XSS_SERVLET)
                        </a></li>
                        
                        <li><a href="#XML_DECODER">
                            XMLDecoder の使用 (XML_DECODER)
                        </a></li>
                        
                        <li><a href="#STATIC_IV">
                            静的な初期化ベクトル (Static IV) (STATIC_IV)
                        </a></li>
                        
                        <li><a href="#ECB_MODE">
                            ECB モードは安全でない (ECB_MODE)
                        </a></li>
                        
                        <li><a href="#PADDING_ORACLE">
                            パディングオラクル攻撃の影響を受けやすい暗号 (PADDING_ORACLE)
                        </a></li>
                        
                        <li><a href="#CIPHER_INTEGRITY">
                            整合性のない暗号 (CIPHER_INTEGRITY)
                        </a></li>
                        
                        <li><a href="#ESAPI_ENCRYPTOR">
                            ESAPI Encryptor の使用 (ESAPI_ENCRYPTOR)
                        </a></li>
                        
                        <li><a href="#ANDROID_EXTERNAL_FILE_ACCESS">
                            外部ファイルアクセス (Android) (ANDROID_EXTERNAL_FILE_ACCESS)
                        </a></li>
                        
                        <li><a href="#ANDROID_BROADCAST">
                            ブロードキャスト (Android) (ANDROID_BROADCAST)
                        </a></li>
                        
                        <li><a href="#ANDROID_WORLD_WRITABLE">
                            ワールドライタブルファイル (Android) (ANDROID_WORLD_WRITABLE)
                        </a></li>
                        
                        <li><a href="#ANDROID_GEOLOCATION">
                            ジオロケーションがアクティブ化された WebView (Android) (ANDROID_GEOLOCATION)
                        </a></li>
                        
                        <li><a href="#ANDROID_WEB_VIEW_JAVASCRIPT">
                            JavaScript を有効にした WebView (Android) (ANDROID_WEB_VIEW_JAVASCRIPT)
                        </a></li>
                        
                        <li><a href="#ANDROID_WEB_VIEW_JAVASCRIPT_INTERFACE">
                            JavaScript インタフェースがある WebView (Android) (ANDROID_WEB_VIEW_JAVASCRIPT_INTERFACE)
                        </a></li>
                        
                        <li><a href="#INSECURE_COOKIE">
                            Secure フラグがない Cookie  (INSECURE_COOKIE)
                        </a></li>
                        
                        <li><a href="#HTTPONLY_COOKIE">
                            HttpOnly フラグがない Cookie  (HTTPONLY_COOKIE)
                        </a></li>
                        
                        <li><a href="#OBJECT_DESERIALIZATION">
                            オブジェクトデシリアライズの使用 (OBJECT_DESERIALIZATION)
                        </a></li>
                        
                        <li><a href="#JACKSON_UNSAFE_DESERIALIZATION">
                            安全でない Jackson のデシリアライズ設定 (JACKSON_UNSAFE_DESERIALIZATION)
                        </a></li>
                        
                        <li><a href="#DESERIALIZATION_GADGET">
                            デシリアライゼーションガジェットとして使用できるクラス (DESERIALIZATION_GADGET)
                        </a></li>
                        
                        <li><a href="#TRUST_BOUNDARY_VIOLATION">
                            Trust Boundary Violation (TRUST_BOUNDARY_VIOLATION)
                        </a></li>
                        
                        <li><a href="#JSP_XSLT">
                            悪意のある XSLT が JSP タグに提供される可能性 (JSP_XSLT)
                        </a></li>
                        
                        <li><a href="#MALICIOUS_XSLT">
                            悪意のある XSLT が提供される可能性 (MALICIOUS_XSLT)
                        </a></li>
                        
                        <li><a href="#SCALA_SENSITIVE_DATA_EXPOSURE">
                            Scala Play における潜在的な情報漏洩 (SCALA_SENSITIVE_DATA_EXPOSURE)
                        </a></li>
                        
                        <li><a href="#SCALA_PLAY_SSRF">
                            Scala Play Server-Side Request Forgery (SSRF) (SCALA_PLAY_SSRF)
                        </a></li>
                        
                        <li><a href="#URLCONNECTION_SSRF_FD">
                            URLConnection Server-Side Request Forgery (SSRF) と File Disclosure (URLCONNECTION_SSRF_FD)
                        </a></li>
                        
                        <li><a href="#SCALA_XSS_TWIRL">
                            Scala Twirl テンプレートエンジンの潜在的な XSS (SCALA_XSS_TWIRL)
                        </a></li>
                        
                        <li><a href="#SCALA_XSS_MVC_API">
                            Scala MVC API エンジンの潜在的な XSS (SCALA_XSS_MVC_API)
                        </a></li>
                        
                        <li><a href="#TEMPLATE_INJECTION_VELOCITY">
                            Velocity の潜在的なテンプレートインジェクション (TEMPLATE_INJECTION_VELOCITY)
                        </a></li>
                        
                        <li><a href="#TEMPLATE_INJECTION_FREEMARKER">
                            Freemarker の潜在的なテンプレートインジェクション (TEMPLATE_INJECTION_FREEMARKER)
                        </a></li>
                        
                        <li><a href="#TEMPLATE_INJECTION_PEBBLE">
                            Pebble の潜在的なテンプレートインジェクション (TEMPLATE_INJECTION_PEBBLE)
                        </a></li>
                        
                        <li><a href="#PERMISSIVE_CORS">
                            過剰に許可された CORS ポリシー (PERMISSIVE_CORS)
                        </a></li>
                        
                        <li><a href="#LDAP_ANONYMOUS">
                            匿名 LDAP バインド (LDAP_ANONYMOUS)
                        </a></li>
                        
                        <li><a href="#LDAP_ENTRY_POISONING">
                            LDAP Entry Poisoning (LDAP_ENTRY_POISONING)
                        </a></li>
                        
                        <li><a href="#COOKIE_PERSISTENT">
                            永続的 Cookie の使用 (COOKIE_PERSISTENT)
                        </a></li>
                        
                        <li><a href="#URL_REWRITING">
                            URL を書き換えるメソッド (URL_REWRITING)
                        </a></li>
                        
                        <li><a href="#INSECURE_SMTP_SSL">
                            安全でない SMTP SSL 接続 (INSECURE_SMTP_SSL)
                        </a></li>
                        
                        <li><a href="#AWS_QUERY_INJECTION">
                            AWS Query インジェクション (AWS_QUERY_INJECTION)
                        </a></li>
                        
                        <li><a href="#BEAN_PROPERTY_INJECTION">
                            JavaBeans プロパティインジェクション (BEAN_PROPERTY_INJECTION)
                        </a></li>
                        
                        <li><a href="#STRUTS_FILE_DISCLOSURE">
                            Struts File Disclosure (STRUTS_FILE_DISCLOSURE)
                        </a></li>
                        
                        <li><a href="#SPRING_FILE_DISCLOSURE">
                            Spring File Disclosure (SPRING_FILE_DISCLOSURE)
                        </a></li>
                        
                        <li><a href="#REQUESTDISPATCHER_FILE_DISCLOSURE">
                            RequestDispatcher File Disclosure (REQUESTDISPATCHER_FILE_DISCLOSURE)
                        </a></li>
                        
                        <li><a href="#FORMAT_STRING_MANIPULATION">
                            書式文字列操作 (FORMAT_STRING_MANIPULATION)
                        </a></li>
                        
                        <li><a href="#HTTP_PARAMETER_POLLUTION">
                            HTTP Parameter Pollution (HTTP_PARAMETER_POLLUTION)
                        </a></li>
                        
                        <li><a href="#INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE">
                            エラーメッセージによる情報漏洩 (INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE)
                        </a></li>
                        
                        <li><a href="#SMTP_HEADER_INJECTION">
                            SMTP ヘッダーインジェクション (SMTP_HEADER_INJECTION)
                        </a></li>
                        
                        <li><a href="#RPC_ENABLED_EXTENSIONS">
                            有効なApache XML RPC サーバーまたはクライアントの拡張機能 (RPC_ENABLED_EXTENSIONS)
                        </a></li>
                        
                        <li><a href="#WICKET_XSS1">
                            HTMLエスケープを無効にすると，アプリケーションが XSS の危険にさらされる (WICKET_XSS1)
                        </a></li>
                        
                        <li><a href="#SAML_IGNORE_COMMENTS">
                            SAML で XML コメントを無視すると，認証バイパスが発生する可能性がある (SAML_IGNORE_COMMENTS)
                        </a></li>
                        
                        <li><a href="#OVERLY_PERMISSIVE_FILE_PERMISSION">
                            過剰に許可されたファイルパーミッション (OVERLY_PERMISSIVE_FILE_PERMISSION)
                        </a></li>
                        
                    </ul>
                </div>
            </div>

    
    <section>
        <a class="anchor" name="PREDICTABLE_RANDOM"></a>
        <h2 class="page-header">
            予測可能な擬似乱数生成器
            <a href="#PREDICTABLE_RANDOM" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>PREDICTABLE_RANDOM</tt></small></em></p>

        
            
<p>セキュリティ上重要なコンテキストで，予測可能な乱数が使用されると脆弱性につながることがあります。たとえば，その乱数が次のように使用されたときです。</p>
<ul>
<li>CSRF トークン:予測可能なトークンは，攻撃者がトークンの価値を知ることになるので，CSRF 攻撃につながる可能性がある</li>
<li>パスワードリセットトークン(電子メールで送信):予測可能なパスワードトークンは，攻撃者が「パスワード変更」フォームのURLを推測するため，アカウントの乗っ取りにつながる可能性がある</li>
<li>その他の秘密の値</li>
</ul>
<p>
手っ取り早い解決策は <code>java.util.Random</code> の使用を <code>java.security.SecureRandom</code> などのより強固なものに置き換えることです。
</p>
<p>
<b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>String generateSecretToken() {
    Random r = new Random();
    return Long.toHexString(r.nextLong());
}</code></pre>
</p>
<p>
<b>解決策:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>import org.apache.commons.codec.binary.Hex;

String generateSecretToken() {
    SecureRandom secRandom = new SecureRandom();

    byte[] result = new byte[32];
    secRandom.nextBytes(result);
    return Hex.encodeHexString(result);
}</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://jazzy.id.au/2010/09/20/cracking_random_number_generators_part_1.html">Cracking Random Number Generators - Part 1 (https://jazzy.id.au)</a><br/>
<a target="_blank" href="https://www.securecoding.cert.org/confluence/display/java/MSC02-J.+Generate+strong+random+numbers">CERT: MSC02-J. Generate strong random numbers</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/330.html">CWE-330: Use of Insufficiently Random Values</a><br/>
<a target="_blank" href="https://blog.h3xstream.com/2014/12/predicting-struts-csrf-token-cve-2014.html">Predicting Struts CSRF Token (Example of real-life vulnerability and exploitation)</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="PREDICTABLE_RANDOM_SCALA"></a>
        <h2 class="page-header">
            予測可能な擬似乱数生成器 (Scala)
            <a href="#PREDICTABLE_RANDOM_SCALA" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>PREDICTABLE_RANDOM_SCALA</tt></small></em></p>

        
            
<p>セキュリティ上重要なコンテキストで，予測可能な乱数が使用されると脆弱性につながることがあります。たとえば，その乱数が次のように使用されたときです。</p>
<ul>
<li>CSRF トークン:予測可能なトークンは，攻撃者がトークンの価値を知ることになるので，CSRF 攻撃につながる可能性がある</li>
<li>パスワードリセットトークン(電子メールで送信):予測可能なパスワードトークンは，攻撃者が「パスワード変更」フォームのURLを推測するため，アカウントの乗っ取りにつながる可能性がある</li>
<li>その他の秘密の値</li>
</ul>
<p>
手っ取り早い解決策は <code>java.util.Random</code> の使用を <b>java.security.SecureRandom</b> などのより強固なものに置き換えることです。
</p>
<p>
<b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>import scala.util.Random

def generateSecretToken() {
    val result = Seq.fill(16)(Random.nextInt)
    return result.map("%02x" format _).mkString
}</code></pre>
</p>
<p>
    <b>解決策:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>import java.security.SecureRandom

def generateSecretToken() {
    val rand = new SecureRandom()
    val value = Array.ofDim[Byte](16)
    rand.nextBytes(value)
    return value.map("%02x" format _).mkString
}</code></pre>
</p>
<!--<p>
<b>解決策:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>import java.security.SecureRandom
import scala.util.Random._

def generateSecretToken() {
    val secRandom = javaRandomToRandom(new SecureRandom())
    val result = Seq.fill(16)(secRandom.nextInt)
    return result.map("%02x" format _).mkString
}</code></pre>
</p>-->
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://jazzy.id.au/2010/09/20/cracking_random_number_generators_part_1.html">Cracking Random Number Generators - Part 1 (http://jazzy.id.au)</a><br/>
<a target="_blank" href="https://www.securecoding.cert.org/confluence/display/java/MSC02-J.+Generate+strong+random+numbers">CERT: MSC02-J. Generate strong random numbers</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/330.html">CWE-330: Use of Insufficiently Random Values</a><br/>
<a target="_blank" href="https://blog.h3xstream.com/2014/12/predicting-struts-csrf-token-cve-2014.html">Predicting Struts CSRF Token (Example of real-life vulnerability and exploitation)</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SERVLET_PARAMETER"></a>
        <h2 class="page-header">
            信頼できないサーブレットパラメーター
            <a href="#SERVLET_PARAMETER" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SERVLET_PARAMETER</tt></small></em></p>

        
            
<p>サーブレットは，さまざまなメソッドから GET と POST のパラメーターを読むことができます。取得した値は安全でないと考えるべきです。
次のような気密性の高い API に値を渡す前に，値を検証またはエスケープする必要があるかもしれません。</p>
<ul>
<li>SQL クエリー (SQL インジェクションにつながる可能性)</li>
<li>ファイルオープン (パストラバーサルにつながる可能性)</li>
<li>コマンド実行 (潜在的なコマンドインジェクション)</li>
<li>HTMLの組み立て (潜在的な XSS)</li>
<li>など...</li>
</ul>

<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SERVLET_CONTENT_TYPE"></a>
        <h2 class="page-header">
            信頼できない Content-Type ヘッダー
            <a href="#SERVLET_CONTENT_TYPE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SERVLET_CONTENT_TYPE</tt></small></em></p>

        
            
<p>
HTTP ヘッダー Content-Type は，クライアントによって操作可能です。したがって，その値をセキュリティ上重要な決定では使用しないでください。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/807.html">CWE-807: Untrusted Inputs in a Security Decision</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SERVLET_SERVER_NAME"></a>
        <h2 class="page-header">
            信頼できない Host ヘッダー
            <a href="#SERVLET_SERVER_NAME" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SERVLET_SERVER_NAME</tt></small></em></p>

        
            
<p>Hostname ヘッダーは，クライアントによって操作可能です。したがって，その値をセキュリティ上重要な決定では使用しないでください。
<code>ServletRequest.getServerName()</code> と <code>HttpServletRequest.getHeader("Host")</code> は，どちらも <code>Host</code> ヘッダーを抽出するという同じ動作をします。</p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>GET /testpage HTTP/1.1
Host: www.example.com
[...]</code></pre>
<p>
アプリケーションにサービスを提供するウェブコンテナは，デフォルトでは，アプリケーションにリクエストをリダイレクトすることがあります。
これにより，悪意のあるユーザーが Host ヘッダーで任意の値を配置できるようになります。
リクエストに関して行うセキュリティ上の決定において，この値を信頼しないことをお勧めします。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/807.html">CWE-807: Untrusted Inputs in a Security Decision</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SERVLET_SESSION_ID"></a>
        <h2 class="page-header">
            信頼できないセッション Cookie の値
            <a href="#SERVLET_SESSION_ID" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SERVLET_SESSION_ID</tt></small></em></p>

        
            
<p>
メソッド <a target="_blank" href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRequestedSessionId()"><code>HttpServletRequest.getRequestedSessionId()</code></a> は，
通常，Cookie  <code>JSESSIONID</code> の値を返します。この値は通常，セッション管理ロジックと正常でない開発者コードだけがアクセスします。
</p>
<p>
クライアントに渡される値は一般的に英数字の値です (たとえば <code>JSESSIONID=jp6q31lq2myn</code>)。しかし，この値はクライアントによって改ざんできます。
次の HTTP リクエストは変更の可能性を示しています。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>GET /somePage HTTP/1.1
Host: yourwebsite.com
User-Agent: Mozilla/5.0
Cookie: JSESSIONID=Any value of the user&#39;s choice!!??'''&quot;&gt;
</code></pre>
</p>
<p>そのため，JSESSIONID は，その値が既存のセッション ID と一致するかどうかを確認するためだけに使用されるべきです。
そうでない場合，そのユーザーは認証されていないユーザーであると考えるべきです。加えて，セッション ID の値をログに記録してはいけません。
その場合，ログファイルに有効なアクティブセッション ID が含まれている可能性があり，インサイダーは ID がログに記録されていてアクティブな状態のセッションをハイジャックできます。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Session_Management_Cheat_Sheet">OWASP: Session Management Cheat Sheet</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>

</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SERVLET_QUERY_STRING"></a>
        <h2 class="page-header">
            信頼できないクエリー文字列
            <a href="#SERVLET_QUERY_STRING" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SERVLET_QUERY_STRING</tt></small></em></p>

        
            
<p>クエリー文字列は，GET パラメーターの名前と値を連結したものです。意図したパラメーター以外を渡すことができます。</p>
<p>URL リクエストが <code>/app/servlet.htm?a=1&b=2</code> のときは，クエリー文字列を抜き出すと <code>a=1&b=2</code> になります。</p>
<p><code>HttpServletRequest.getParameter()</code> のようなメソッドで取得した個々のパラメーター値と同じように，<code>HttpServletRequest.getQueryString()</code> から取得した値は安全でないと見なすべきです。
気密性の高い API に渡す前に，クエリー文字列から取得したものを検証またはエスケープする必要があります。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SERVLET_HEADER"></a>
        <h2 class="page-header">
            信頼できない HTTP ヘッダー
            <a href="#SERVLET_HEADER" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SERVLET_HEADER</tt></small></em></p>

        
            
<p>リクエストヘッダーはリクエストしているユーザーによって容易に改ざんできます。
一般的には，ブラウザーからリクエストが攻撃者によって変更されることなく来ることを仮定すべきではありません。
このように，リクエストに関して行うあらゆるセキュリティ上の決定において，その値を信頼しないことをお勧めします。</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/807.html">CWE-807: Untrusted Inputs in a Security Decision</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SERVLET_HEADER_REFERER"></a>
        <h2 class="page-header">
            信頼できない Referer ヘッダー
            <a href="#SERVLET_HEADER_REFERER" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SERVLET_HEADER_REFERER</tt></small></em></p>

        
            
<p>
動作:
<ul>
<li>リクエストが悪意のあるユーザーから来ているなら，任意の値をこのヘッダーに割り当てられる</li>
<li>リクエストが安全 (HTTPS) である別のオリジンから開始されたときは，"Referer" は存在しない</li>
</ul>
</p>
<p>
推奨:
<ul>
<li>このヘッダーの値に基づいてアクセス制御を行うべきではない</li>
<li>CSRF 保護は，この値にだけ基づいて行われるべきではない (<a target="_blank" href="https://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14">オプションなので</a>)</li>
</ul>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/807.html">CWE-807: Untrusted Inputs in a Security Decision</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SERVLET_HEADER_USER_AGENT"></a>
        <h2 class="page-header">
            信頼できない User-Agent ヘッダー
            <a href="#SERVLET_HEADER_USER_AGENT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SERVLET_HEADER_USER_AGENT</tt></small></em></p>

        
            
<p>ヘッダー "User-Agent" は，クライアントによって容易に偽装できます。User-Agent に基づいて (クローラー UA に対して) 異なった動作をすることは推奨できません。</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/807.html">CWE-807: Untrusted Inputs in a Security Decision</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="COOKIE_USAGE"></a>
        <h2 class="page-header">
             Cookie 内に機密データの可能性
            <a href="#COOKIE_USAGE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>COOKIE_USAGE</tt></small></em></p>

        
            
<p>カスタム Cookie に格納する情報は，機密やセッションに関連してはいけません。ほとんどの場合，機密データはセッションだけに格納して，ユーザーのセッション Cookie によってだけ参照されるべきです。
HttpSession (<code>HttpServletRequest.getSession()</code>) を参照してください。</p>
<p>カスタム Cookie は，特定のセッションから独立した，より長く存続する必要がある情報のために使用できます。</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/315.html">CWE-315: Cleartext Storage of Sensitive Information in a Cookie</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="PATH_TRAVERSAL_IN"></a>
        <h2 class="page-header">
            潜在的なパストラバーサル (ファイル読み出し)
            <a href="#PATH_TRAVERSAL_IN" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>PATH_TRAVERSAL_IN</tt></small></em></p>

        
            
<p>内容を読むためにファイルが開かれています。ファイル名は <b>入力</b> パラメーターに由来しています。
フィルターされていないパラメーターがこのファイル API に渡されると，ファイルシステムの任意の場所からファイルを読み出せるかもしれません。</p>
<p>このルールは <b>潜在的な</b> パストラバーサルの脆弱性を特定します。多くの場合，構築されたファイルパスはユーザーが制御できません。
その場合，報告された事例は誤検出です。</p>
<br/>

<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>@GET
@Path("/images/{image}")
@Produces("images/*")
public Response getImage(@javax.ws.rs.PathParam("image") String image) {
    File file = new File("resources/images/", image); //Weak point

    if (!file.exists()) {
        return Response.status(Status.NOT_FOUND).build();
    }

    return Response.ok().entity(new FileInputStream(file)).build();
}</code></pre>
</p>
<br/>

<p>
    <b>解決策:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>import org.apache.commons.io.FilenameUtils;

@GET
@Path("/images/{image}")
@Produces("images/*")
public Response getImage(@javax.ws.rs.PathParam("image") String image) {
    File file = new File("resources/images/", FilenameUtils.getName(image)); //Fix

    if (!file.exists()) {
        return Response.status(Status.NOT_FOUND).build();
    }

    return Response.ok().entity(new FileInputStream(file)).build();
}</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246952/Path%20Traversal">WASC: Path Traversal</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Path_Traversal">OWASP: Path Traversal</a><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/126.html">CAPEC-126: Path Traversal</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/22.html">CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="PATH_TRAVERSAL_OUT"></a>
        <h2 class="page-header">
            潜在的なパストラバーサル (ファイル書き込み)
            <a href="#PATH_TRAVERSAL_OUT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>PATH_TRAVERSAL_OUT</tt></small></em></p>

        
            
<p>内容を書くためにファイルが開かれています。ファイル名は <b>入力</b> パラメーターに由来しています。
フィルターされていないパラメーターがこのファイル API に渡されると，ファイルシステムの任意の場所からファイルを変更できるかもしれません。</p>
<p>このルールは <b>潜在的な</b> パストラバーサルの脆弱性を特定します。多くの場合，構築されたファイルパスはユーザーが制御できません。
その場合，報告された事例は誤検出です。</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246952/Path%20Traversal">WASC-33: Path Traversal</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Path_Traversal">OWASP: Path Traversal</a><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/126.html">CAPEC-126: Path Traversal</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/22.html">CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SCALA_PATH_TRAVERSAL_IN"></a>
        <h2 class="page-header">
            Scala API を使用した潜在的なパストラバーサル (ファイル読み出し)
            <a href="#SCALA_PATH_TRAVERSAL_IN" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SCALA_PATH_TRAVERSAL_IN</tt></small></em></p>

        
            
<p>内容を読むためにファイルが開かれています。ファイル名は <b>入力</b> パラメーターに由来しています。
フィルターされていないパラメーターがこのファイル API に渡されると，ファイルシステムの任意の場所からファイルを読み出せるかもしれません。</p>
<p>このルールは <b>潜在的な</b> パストラバーサルの脆弱性を特定します。多くの場合，構築されたファイルパスはユーザーが制御できません。
その場合，報告された事例は誤検出です。</p>
<br/>

<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>def getWordList(value:String) = Action {
  if (!Files.exists(Paths.get("public/lists/" + value))) {
    NotFound("File not found")
  } else {
    val result = Source.fromFile("public/lists/" + value).getLines().mkString // 弱点
    Ok(result)
  }
}</code></pre>
</p>
<br/>

<p>
    <b>解決策:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>import org.apache.commons.io.FilenameUtils;

def getWordList(value:String) = Action {
  val filename = "public/lists/" + FilenameUtils.getName(value)

  if (!Files.exists(Paths.get(filename))) {
    NotFound("File not found")
  } else {
    val result = Source.fromFile(filename).getLines().mkString // 修正
    Ok(result)
  }
}</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246952/Path%20Traversal">WASC: Path Traversal</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Path_Traversal">OWASP: Path Traversal</a><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/126.html">CAPEC-126: Path Traversal</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/22.html">CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="COMMAND_INJECTION"></a>
        <h2 class="page-header">
            潜在的なコマンドインジェクション
            <a href="#COMMAND_INJECTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>COMMAND_INJECTION</tt></small></em></p>

        
            
<p>強調表示された API は，システムコマンドを実行するために使用されています。
フィルタされていない入力がこの API に渡されると，任意のコマンド実行につながる可能性があります。</p>
<br/>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>import java.lang.Runtime;

Runtime r = Runtime.getRuntime();
r.exec("/bin/sh -c some_tool" + input);</code></pre>
</p>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Command_Injection">OWASP: Command Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/78.html">CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SCALA_COMMAND_INJECTION"></a>
        <h2 class="page-header">
            潜在的なコマンドインジェクション (Scala)
            <a href="#SCALA_COMMAND_INJECTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SCALA_COMMAND_INJECTION</tt></small></em></p>

        
            
<p>強調表示された API は，システムコマンドを実行するために使用されています。
フィルタされていない入力がこの API に渡されると，任意のコマンド実行につながる可能性があります。</p>
<br/>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>def executeCommand(value:String) = Action {
    val result = value.!
    Ok("Result:\n"+result)
}</code></pre>
</p>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Command_Injection">OWASP: Command Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/78.html">CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="WEAK_FILENAMEUTILS"></a>
        <h2 class="page-header">
            FilenameUtils は NULL バイトをフィルタリングしない
            <a href="#WEAK_FILENAMEUTILS" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>WEAK_FILENAMEUTILS</tt></small></em></p>

        
            
<p><code>FilenameUtils'</code> メソッドの中には，NULLバイト (<code>0x00</code>) をフィルタしないものもあります。</p>
<p>NULL バイトがファイル名に挿入され，そのファイル名が OS に渡されると取得されるファイルは NULL バイトより前に指定されたファイル名になります。
OS レベルであるので，たとえ Java 自体が NULLl バイトを気にしたり特別扱いをしなくても，すべての文字列が NULL バイトで終了するためです。
この OS の動作は，ファイル名の検証を「ファイル名の末尾 (たとえば，末尾が <code>".log"</code> であるか) を調べ，アクセスしても安全なファイルであるかを確認」といった具合にしていると回避されてしまうことがあります。</p>
<p>これを修正するためには，次の2つのことが推奨されています:</p>
<ul>
<li>Java 7 update 40 以降，または Java 8 以上へのアップグレード
<a target="_blank" href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8014846">NNULL バイトインジェクションはそれらのバージョンで修正されている</a></li>
<li>信頼できないユーザーによって与えられた任意のファイル名が有効であることを確認するため，入念に検証する (すなわち，null が含まれていないか，パス文字が加えられていないかなど)</li>
</ul>
<p>NULL バイトインジェクションの影響を受けない最新版の Java を使用していることがわかっているなら，このルールを無効にできます。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246949/Null%20Byte%20Injection">WASC-28: Null Byte Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/158.html">CWE-158: Improper Neutralization of Null Byte or NUL Character</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="WEAK_TRUST_MANAGER"></a>
        <h2 class="page-header">
            任意の証明書を受け入れる TrustManager
            <a href="#WEAK_TRUST_MANAGER" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>WEAK_TRUST_MANAGER</tt></small></em></p>

        
            
<p>空の <code>TrustManager</code> 実装は，多くの場合，
ルート <a target="_blank" href="https://en.wikipedia.org/wiki/Certificate_authority">認証局</a> によって署名されていないホストに簡単に接続するために使用されます。
結果として，クライアントがどの証明書も信頼してしまうので，
<a target="_blank" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">中間者攻撃 (Man-in-the-middle attacks)</a> に対して脆弱です。
</p>
<p>
(たとえば，TrustStore に基づいて) 特定の証明書を許可する TrustManager を構築すべきです。
適切な実装の詳細については:
<a target="_blank" href="https://stackoverflow.com/a/6378872/89769">[1]</a>
<a target="_blank" href="https://stackoverflow.com/a/5493452/89769">[2]</a>
</p>
<br/>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>class TrustAllManager implements X509TrustManager {

    @Override
    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
        //Trust any client connecting (no certificate validation)
    }

    @Override
    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
        //Trust any remote server (no certificate validation)
    }

    @Override
    public X509Certificate[] getAcceptedIssuers() {
        return null;
    }
}</code></pre>
</p>
<br/>
<p>
    <b>解決策 (キーストアに基づく TrustMangager):</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>KeyStore ks = //Load keystore containing the certificates trusted

SSLContext sc = SSLContext.getInstance("TLS");

TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
tmf.init(ks);

sc.init(kmf.getKeyManagers(), tmf.getTrustManagers(),null);
</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246945/Insufficient%20Transport%20Layer%20Protection">WASC-04: Insufficient Transport Layer Protection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/295.html">CWE-295: Improper Certificate Validation</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="WEAK_HOSTNAME_VERIFIER"></a>
        <h2 class="page-header">
            任意の署名付き証明書を受け入れる HostnameVerifier
            <a href="#WEAK_HOSTNAME_VERIFIER" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>WEAK_HOSTNAME_VERIFIER</tt></small></em></p>

        
            
<p>任意のホストを受け入れる <code>HostnameVerifier</code> は，多くのホストで証明書を再利用するためによく使用されます。
結果として，クライアントがどの証明書も信頼してしまうので，これは <a target="_blank" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">中間者攻撃 (Man-in-the-middle attacks)</a> に対して脆弱です。
</p>
<p>
(たとえば，TrustStore に基づいて) 特定の証明書を許可する TrustManager を構築すべきです。
複数のサブドメインで再利用するためのワイルドカード証明書を作成すべきです。
適切な実装の詳細については:
<a target="_blank" href="https://stackoverflow.com/a/6378872/89769">[1]</a>
<a target="_blank" href="https://stackoverflow.com/a/5493452/89769">[2]</a>
</p>
<br/>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public class AllHosts implements HostnameVerifier {
    public boolean verify(final String hostname, final SSLSession session) {
        return true;
    }
}</code></pre>
</p>
<br/>
<p>
    <b>解決策 (キーストアに基づく TrustMangager):</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>KeyStore ks = //Load keystore containing the certificates trusted

SSLContext sc = SSLContext.getInstance("TLS");

TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
tmf.init(ks);

sc.init(kmf.getKeyManagers(), tmf.getTrustManagers(),null);
</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246945/Insufficient%20Transport%20Layer%20Protection">WASC-04: Insufficient Transport Layer Protection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/295.html">CWE-295: Improper Certificate Validation</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="JAXWS_ENDPOINT"></a>
        <h2 class="page-header">
            JAX-WS SOAP エンドポイントを発見
            <a href="#JAXWS_ENDPOINT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>JAXWS_ENDPOINT</tt></small></em></p>

        
            
<p>このメソッドは，SOAP Web サービス (JSR224) の一部です。</p>
<p>
<b>この Web サービスの安全性を分析するべきです。たとえば:</b>
<ul>
<li>認証を強制したときはテストすべき</li>
<li>アクセス制御を強制したときはテストすべき</li>
<li>潜在的な脆弱性のために入力を追跡すべき</li>
<li>通信は理想的には SSL の上で行うべき</li>
</ul>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Web_Service_Security_Cheat_Sheet">OWASP: Web Service Security Cheat Sheet</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="JAXRS_ENDPOINT"></a>
        <h2 class="page-header">
            JAX-RS REST エンドポイントを発見
            <a href="#JAXRS_ENDPOINT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>JAXRS_ENDPOINT</tt></small></em></p>

        
            
<p>このメソッドは REST Web サービス (JSR311) の一部です。</p>
<p>
<b>この Web サービスの安全性を分析するべきです。たとえば:</b>
<ul>
<li>認証を強制したときはテストすべき</li>
<li>アクセス制御を強制したときはテストすべき</li>
<li>潜在的な脆弱性のために入力を追跡すべき</li>
<li>通信は理想的には SSL の上で行うべき</li>
<li>サービスが書き込み (POSTなど) をサポートしているときは，CSRF に対する脆弱性を調査すべき</li>
</ul>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://www.owasp.org/index.php/REST_Assessment_Cheat_Sheet">OWASP: REST Assessment Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/REST_Security_Cheat_Sheet">OWASP: REST Security Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Web_Service_Security_Cheat_Sheet">OWASP: Web Service Security Cheat Sheet</a><br/>
1. <a target="_blank" href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)">OWASP: Cross-Site Request Forgery</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet">OWASP: CSRF Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="TAPESTRY_ENDPOINT"></a>
        <h2 class="page-header">
            Tapestry ページを発見
            <a href="#TAPESTRY_ENDPOINT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>TAPESTRY_ENDPOINT</tt></small></em></p>

        
            
<p>アプリケーション起動時に Tapestry エンドポイントが検出されました。
Tapestry アプリケーションは，各ページのバッキング Java クラスと対応する Tapestry マークアップ言語ページ (<code>.tml</code> ファイル) で構成されます。
リクエストが受信されると，GET/POST パラメーターはバッキング Java クラス内の特定の入力にマッピングされます。
マッピングはいずれかで行われます。フィールド名で:</p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'><code>
    [...]
    protected String input;
    [...]
</code></code></pre>
<p>または，明示的なアノテーションの定義で:
</p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'><code>
    [...]
    @org.apache.tapestry5.annotations.Parameter
    protected String parameter1;

    @org.apache.tapestry5.annotations.Component(id = "password")
    private PasswordField passwordField;
    [...]
</code></code></pre>
<p>ページは，ビュー  <code>/resources/package/PageName.tml</code> にマッピングされます。</p>
<p>このアプリケーションの各 Tapestry ページは，このように自動的にマッピングされるすべての入力が使用される前に適切に検証されているか調査すべきです。</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://tapestry.apache.org/">Apache Tapestry Home Page</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="WICKET_ENDPOINT"></a>
        <h2 class="page-header">
            Wicket ページを発見
            <a href="#WICKET_ENDPOINT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>WICKET_ENDPOINT</tt></small></em></p>

        
            
<p>このクラスは，Wicket WebPage を表します。入力はコンストラクターに渡された PageParameters インスタンスから自動的に読み出されます。
現在のページは，ビュー <code>/package/WebPageName.html</code> にマッピングされます。</p>
<p>このアプリケーションの各 Wicket ページは，このように自動的にマッピングされるすべての入力を使用される前に適切に検証されているか調査すべきです。</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://wicket.apache.org/">Apache Wicket Home Page</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="WEAK_MESSAGE_DIGEST_MD5"></a>
        <h2 class="page-header">
            MD2，MD4，MD5 は弱いハッシュ関数
            <a href="#WEAK_MESSAGE_DIGEST_MD5" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>WEAK_MESSAGE_DIGEST_MD5</tt></small></em></p>

        
            
<p>アルゴリズム MD2，MD4，MD5 は推奨されているメッセージダイジェストではありません。
<b>PBKDF2 (Password-Based Key Derivation Function 2)</b> は，たとえばパスワードをハッシュ化するために使用すべきです。</p>

<blockquote>
    「MD5 ハッシュ関数のセキュリティは深刻に損なわれています。
    2.6 GHz Pentium 4 プロセッサー (複雑さは 2<sup>24.1</sup>) のコンピューターで数秒で衝突を見つけられる衝突攻撃が存在します。[1]
    さらに，既製のコンピューティングハードウェア (複雑さは 2<sup>39</sup>) を使用して，数時間以内に指定されたプレフィックスを持つ2つの入力の衝突を生成する選択プリフィックス衝突攻撃もあります。[2]」<br/>
    - <a target="_blank" href="https://en.wikipedia.org/wiki/MD5#Security">Wikipedia: MD5 - Security</a>
</blockquote>

<blockquote>
    「<b>SHA-224，SHA-256，SHA-384，SHA-512，SHA-512/224，SHA-512/256</b>:<br/>
    これらのハッシュ関数の使用は，すべてのハッシュ関数アプリケーションで許容されています。」<br/>
    - <a target="_blank" href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf">NIST: Transitioning the Use of Cryptographic Algorithms and Key Lengths p.15</a>
</blockquote>
<blockquote>
    「PBKDF (Password-Based Key Derivation Function) の主な考え方は，各パスワードをテストするために必要な時間を増やすことによって，パスワードに対する辞書攻撃またはブルートフォース攻撃を遅延させることです。
    もっともらしいパスワードのリストを持つ攻撃者は，既知の反復カウンタと salt を使用して PBKDF を評価できます。
    攻撃者は試行ごとにかなりの計算時間を費やさなければならないので，辞書攻撃やブルートフォース攻撃を適用するのが難しくなります。」<br/>
- <a target="_blank" href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf">NIST: Recommendation for Password-Based Key Derivation  p.12</a>
</blockquote>
<br/>
<p>
    <b>脆弱なコード:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>MessageDigest md5Digest = MessageDigest.getInstance("MD5");
    md5Digest.update(password.getBytes());
    byte[] hashValue = md5Digest.digest();</code></pre>
    <br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>byte[] hashValue = DigestUtils.getMd5Digest().digest(password.getBytes());</code></pre>
</p>
<br/>
<p>
    <b>解決策 (Bouncy Castle を使う):</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
    PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());
    gen.init(password.getBytes("UTF-8"), salt.getBytes(), 4096);
    return ((KeyParameter) gen.generateDerivedParameters(256)).getKey();
}</code></pre>
    <br/>
    <b>解決策 (Java 8 以降):</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);
    SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
    return f.generateSecret(spec).getEncoded();
}</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
[1] <a target="_blank" href="https://www.win.tue.nl/hashclash/On%20Collisions%20for%20MD5%20-%20M.M.J.%20Stevens.pdf">On Collisions for MD5</a>: Master Thesis by M.M.J. Stevens<br/>
[2] <a target="_blank" href="https://homepages.cwi.nl/~stevens/papers/stJOC%20-%20Chosen-Prefix%20Collisions%20for%20MD5%20and%20Applications.pdf">Chosen-prefix collisions for MD5 and applications</a>: Paper written by Marc Stevens<br/>
<a target="_blank" href="https://en.wikipedia.org/wiki/MD5">Wikipedia: MD5</a><br/>
<a target="_blank" href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf">NIST: Transitioning the Use of Cryptographic Algorithms and Key Lengths</a><br/>
<a target="_blank" href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf">NIST: Recommendation for Password-Based Key Derivation</a><br/>
<a target="_blank" href="https://stackoverflow.com/q/22580853/89769">Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/327.html">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="WEAK_MESSAGE_DIGEST_SHA1"></a>
        <h2 class="page-header">
            SHA-1 は弱いハッシュ関数
            <a href="#WEAK_MESSAGE_DIGEST_SHA1" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>WEAK_MESSAGE_DIGEST_SHA1</tt></small></em></p>

        
            
<p>アルゴリズム SHA-1 は，ハッシュパスワード，署名検証などのために推奨されるアルゴリズムではありません。
<b>PBKDF2 (Password-Based Key Derivation Function 2)</b> は，たとえばパスワードをハッシュ化するために使用すべきです。</p>

<blockquote>
    「<b>デジタル署名生成用の SHA-1:</b><br/>
    SHA-1は，NIST プロトコル仕様ガイダンスで特に許可されているデジタル署名の生成にだけ使用できます。
    他のすべてのアプリケーションでは，<u>SHA-1 をデジタル署名の生成に使用してはいけません</u>。<br/>
    <b>デジタル署名検証用の SHA-1:</b><br/>
    デジタル署名検証では，<u>SHA-1 は従来の使用が許可されています</u>。<br/>
    [...]<br/>
    <b>SHA-224，SHA-256，SHA-384，SHA-512，SHA-512/224，SHA-512/256</b>:<br/>
    これらのハッシュ関数の使用は，すべてのハッシュ関数アプリケーションで許容されています。」<br/>
    - <a target="_blank" href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf">NIST: Transitioning the Use of Cryptographic Algorithms and Key Lengths p.15</a>
</blockquote>
<blockquote>
    「PBKDF (Password-Based Key Derivation Function) の主な考え方は，各パスワードをテストするために必要な時間を増やすことによって，パスワードに対する辞書攻撃またはブルートフォース攻撃を遅延させることです。
    もっともらしいパスワードのリストを持つ攻撃者は，既知の反復カウンタと salt を使用して PBKDF を評価できます。
    攻撃者は試行ごとにかなりの計算時間を費やさなければならないので，辞書攻撃やブルートフォース攻撃を適用するのが難しくなります。」<br/>
- <a target="_blank" href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf">NIST: Recommendation for Password-Based Key Derivation  p.12</a>

</blockquote>
<br/>
<p>
    <b>脆弱なコード:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>MessageDigest sha1Digest = MessageDigest.getInstance("SHA1");
    sha1Digest.update(password.getBytes());
    byte[] hashValue = sha1Digest.digest();</code></pre>
    <br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>byte[] hashValue = DigestUtils.getSha1Digest().digest(password.getBytes());</code></pre>
</p>
<br/>
<p>
    <b>解決策 (Bouncy Castle を使う):</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
    PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());
    gen.init(password.getBytes("UTF-8"), salt.getBytes(), 4096);
    return ((KeyParameter) gen.generateDerivedParameters(256)).getKey();
}</code></pre>
    <br/>
    <b>解決策 (Java 8 以降):</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);
    SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
    return f.generateSecret(spec).getEncoded();
}</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://community.qualys.com/blogs/securitylabs/2014/09/09/sha1-deprecation-what-you-need-to-know">Qualys blog: SHA1 Deprecation: What You Need to Know</a><br/>
<a target="_blank" href="https://googleonlinesecurity.blogspot.ca/2014/09/gradually-sunsetting-sha-1.html">Google Online Security Blog: Gradually sunsetting SHA-1</a><br/>
<a target="_blank" href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf">NIST: Transitioning the Use of Cryptographic Algorithms and Key Lengths</a><br/>
<a target="_blank" href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf">NIST: Recommendation for Password-Based Key Derivation</a><br/>
<a target="_blank" href="https://stackoverflow.com/q/22580853/89769">Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/327.html">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="DEFAULT_HTTP_CLIENT"></a>
        <h2 class="page-header">
            デフォルトのコンストラクターを持つ DefaultHttpClient は TLS 1.2 と互換性がない
            <a href="#DEFAULT_HTTP_CLIENT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>DEFAULT_HTTP_CLIENT</tt></small></em></p>

        
            
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>HttpClient client = new DefaultHttpClient();</code></pre>
</p>
<p>
<p><b>解決策:</b><br/>
推奨構成の1つを使用して，<code>https.protocols</code> JVM オプションを TLSv1.2 を含むように設定して，実装を改良します:</p>
<p>
<ul>
  <li>代わりに <a target="_blank" href="https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/impl/client/SystemDefaultHttpClient.html">SystemDefaultHttpClient</a> を使用する</li>
<p>
    <b>サンプルコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>HttpClient client = new SystemDefaultHttpClient();</code></pre>
</p>
  <li>SSLSocketFactory に基づいて HttpClient を作成する - <a target="_blank" href="https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/conn/ssl/SSLSocketFactory.html#getSystemSocketFactory()"><code>getSystemSocketFactory()</code></a> で SSLSocketFactory のインスタンスを取得して，HttpClient の作成に使用する</li>
  <li>SSLConnectionSocketFactory に基づいて HttpClient を作成する - <a target="_blank" href="https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/conn/ssl/SSLConnectionSocketFactory.html#getSystemSocketFactory()"><code>getSystemSocketFactory()</code></a> でインスタンスを取得して，HttpClient の作成に使用する</li>
  <li>HttpClientBuilder を使用する - <code>build()</code> を呼び出す前に <a target="_blank" href="https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/impl/client/HttpClientBuilder.html#useSystemProperties()"><code>useSystemProperties()</code></a> を呼び出す</li>
<p>
    <b>サンプルコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>HttpClient client = HttpClientBuilder.create().useSystemProperties().build();</code></pre>
</p>
  <li>HttpClients - <a target="_blank" href="https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/impl/client/HttpClients.html#createSystem()"><code>createSystem()</code></a> を呼び出してインスタンスを作成する</li>
<p>
    <b>サンプルコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>HttpClient client = HttpClients.createSystem();</code></pre>
</p>
</ul>
</p>
<br/>

<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://blogs.oracle.com/java-platform-group/entry/diagnosing_tls_ssl_and_https">Diagnosing TLS, SSL, and HTTPS</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SSL_CONTEXT"></a>
        <h2 class="page-header">
            弱い SSLContext
            <a href="#SSL_CONTEXT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SSL_CONTEXT</tt></small></em></p>

        
            
<p>
    <b>脆弱なコード:</b><br/>

    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>SSLContext.getInstance("SSL");</code></pre>
</p>
<p>
<p><b>解決策:</b><br/>

<code>https.protocols</code> JVM オプションを TLSv1.2を含むように設定して，実装を改良します:</p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>SSLContext.getInstance("TLS");</code></pre>
<p>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://blogs.oracle.com/java-platform-group/entry/diagnosing_tls_ssl_and_https">Diagnosing TLS, SSL, and HTTPS</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="CUSTOM_MESSAGE_DIGEST"></a>
        <h2 class="page-header">
            独自メッセージダイジェスト
            <a href="#CUSTOM_MESSAGE_DIGEST" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>CUSTOM_MESSAGE_DIGEST</tt></small></em></p>

        
            
<p>独自メッセージダイジェストの実装は間違いの元になりやすいです。</p>
<p><a target="_blank" href="https://csrc.nist.gov/projects/hash-functions">NIST</a> は，SHA-224，SHA-256，SHA-384，SHA-512，SHA-512/224，SHA-512/256 の使用を推奨しています。</p>
<blockquote>
    「<b>デジタル署名生成用の SHA-1:</b><br/>
    SHA-1は，NIST プロトコル仕様ガイダンスで特に許可されているデジタル署名の生成にだけ使用できます。
    他のすべてのアプリケーションでは，<u>SHA-1 をデジタル署名の生成に使用してはいけません</u>。<br/>
    <b>デジタル署名検証用の SHA-1:</b><br/>
    デジタル署名検証では，<u>SHA-1 は従来の使用が許可されています</u>。<br/>
    [...]<br/>
    <b>SHA-224，SHA-256，SHA-384，SHA-512，SHA-512/224，SHA-512/256</b>:<br/>
    これらのハッシュ関数の使用は，すべてのハッシュ関数アプリケーションで許容されています。」<br/>
    - <a target="_blank" href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf">NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.15</a>
</blockquote>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>MyProprietaryMessageDigest extends MessageDigest {
    @Override
    protected byte[] engineDigest() {
        [...]
        // 独創性は悪い考え
        return [...];
    }
}</code></pre>
</p>
<p>
<p>承認されたアルゴリズムの1つを使用するように実装を改良します。セキュリティニーズを満たす十分に強いアルゴリズムを使用します。</p>
<p>
    <b>解決例:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>MessageDigest sha256Digest = MessageDigest.getInstance("SHA256");
sha256Digest.update(password.getBytes());</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://csrc.nist.gov/projects/hash-functions">NIST Approved Hash Functions</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/327.html">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="FILE_UPLOAD_FILENAME"></a>
        <h2 class="page-header">
            汚染されたファイル名の読み取り
            <a href="#FILE_UPLOAD_FILENAME" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>FILE_UPLOAD_FILENAME</tt></small></em></p>

        
            
<p>FileUpload API によって与えられたファイル名は，権限のないファイルを参照するためにクライアントによって改ざんされる可能性があります。</p>
<p>たとえば:</p>
<ul>
<li><code>"../../../config/overide_file"</code></li>
<li><code>"shell.jsp\u0000expected.gif"</code></li>
</ul>
<p>したがって，そのような値を直接ファイルシステム API に渡すべきではありません。可能であれば，アプリケーションは独自のファイル名を生成して使用すべきです。
そうでなければ与えられたファイル名を「不正なパス文字 (たとえば/ \) が含まれていない」や「許可されたファイルを参照している」というように，正しく構成されているか検証すべきです。</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://blogs.securiteam.com/index.php/archives/1268">Securiteam: File upload security recommendations</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/22.html">CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</a><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246952/Path%20Traversal">WASC-33: Path Traversal</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Path_Traversal">OWASP: Path Traversal</a><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/126.html">CAPEC-126: Path Traversal</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/22.html">CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="REDOS"></a>
        <h2 class="page-header">
            正規表現による DoS (ReDoS)
            <a href="#REDOS" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>REDOS</tt></small></em></p>

        
            
<p>
正規表現 (Regex) は，DoS攻撃 (ReDoS と呼ばれる) の対象となることがよくあります。
これは，正規表現がどのように定義されているかに応じて，正規表現エンジンが特定の文字列を解析するときに長い時間がかかることが原因です。
<p>
たとえば，次の正規表現の場合: <code>^(a+)+$</code>，"<code>aaaaaaaaaaaaaaaaX</code>" を入力すると正規表現エンジンは 65536 通りの異なるパスを解析します。
<sup>[1] OWASP リファレンスから抜粋した例</sup></p>
<p>
したがって，1回のリクエストでサーバー側で大量の計算が発生する可能性があります。
この正規表現 (およびその他同様のもの) に関連する問題は，括弧の内側にある <code>+</code> (または <code>*</code>) と括弧の外側にある <code>+</code> (または <code>*</code>) によって，同じ入力文字を2つの異なる方法で受け入れられるということです。
この書き方は，どちらの <code>+</code> でも文字 'a' を消費します。これを修正するには，曖昧さを解消するように正規表現を書き直すべきです。
たとえば，<code>^a+$</code> のようにたやすく書き直すことができます。それは，おそらく作者の意図していることです (a がいくつあっても)。
これが元の正規表現を意図しているなら，この新しい正規表現はすぐに評価されるので，ReDoS の対象とはなりません。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://sebastiankuebeck.wordpress.com/2011/03/01/detecting-and-preventing-redos-vulnerabilities/">Sebastian Kubeck's Weblog: Detecting and Preventing ReDoS Vulnerabilities</a><br/>
<sup>[1]</sup> <a target="_blank" href="https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS">OWASP: Regular expression Denial of Service</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/400.html">CWE-400: Uncontrolled Resource Consumption ('Resource Exhaustion')</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="XXE_XMLSTREAMREADER"></a>
        <h2 class="page-header">
            XXE に脆弱な XML 解析 (XMLStreamReader)
            <a href="#XXE_XMLSTREAMREADER" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>XXE_XMLSTREAMREADER</tt></small></em></p>

        
            
<!--XXE_GENERIC_START-->
<h3>攻撃</h3>
<p>信頼されていないソースから受け取った XML を処理しているときに，XML パーサーが XML エンティティをサポートしていると XML 外部エンティティ (XXE:XML External Entity) 攻撃が発生する可能性があります。</p>
<p><b>リスク 1: ローカルファイルの内容の暴露 (XXE: <u>X</u>ML E<u>x</u>ternal <u>E</u>ntity)</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre>
</p>
<b>リスク 2: サービス拒否 (XEE: <u>X</u>ML <u>E</u>ntity <u>E</u>xpansion)</b>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol &quot;lol&quot;&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
 &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;
 &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
[...]
 &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre>
</p>

<h3>解決策</h3>
<p>
XML パーサーの危険な機能が公開されないようにするためには，コードを次のように変更します。
</p>
<!--XXE_GENERIC_END-->

<p><b>脆弱なコード:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public void parseXML(InputStream input) throws XMLStreamException {

    XMLInputFactory factory = XMLInputFactory.newFactory();
    XMLStreamReader reader = factory.createXMLStreamReader(input);
    [...]
}</code></pre>
</p>
<br/>
<p>
次のスニペットでは，利用可能な2つの解決策を示しています。1つまたは両方の機能を設定します。
</p>

<p><b>外部エンティティーを無効にする解決策:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public void parseXML(InputStream input) throws XMLStreamException {

    XMLInputFactory factory = XMLInputFactory.newFactory();
    factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
    XMLStreamReader reader = factory.createXMLStreamReader(input);
    [...]
}</code></pre>
</p>

<p><b>DTD を無効にする解決策:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public void parseXML(InputStream input) throws XMLStreamException {

    XMLInputFactory factory = XMLInputFactory.newFactory();
    factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);
    XMLStreamReader reader = factory.createXMLStreamReader(input);
    [...]
}</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<!--XXE_GENERIC_START-->
<a target="_blank" href="https://cwe.mitre.org/data/definitions/611.html">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a target="_blank" href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_Entity_Expansion">WS-Attacks.org: XML Entity Expansion</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_External_Entity_DOS">WS-Attacks.org: XML External Entity DOS</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a target="_blank" href="https://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html">Identifying XML External Entity vulnerability (XXE)</a><br/>
<!--XXE_GENERIC_END-->
<a target="_blank" href="https://openjdk.java.net/jeps/185">JEP 185: Restrict Fetching of External XML Resources</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="XXE_XPATH"></a>
        <h2 class="page-header">
            XXE に脆弱な XML 解析 (XPathExpression)
            <a href="#XXE_XPATH" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>XXE_XPATH</tt></small></em></p>

        
            
<!--XXE_GENERIC_START-->
<h3>攻撃</h3>
<p>信頼されていないソースから受け取った XML を処理しているときに，XML パーサーが XML エンティティをサポートしていると XXE (XML External Entity) 攻撃が発生する可能性があります。</p>
<p><b>リスク 1: ローカルファイルの内容の暴露 (XXE: <u>X</u>ML E<u>x</u>ternal <u>E</u>ntity)</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre>
</p>
<b>リスク 2: サービス拒否 (XEE: <u>X</u>ML <u>E</u>ntity <u>E</u>xpansion)</b>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol &quot;lol&quot;&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
 &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;
 &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
[...]
 &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre>
</p>

<h3>解決策</h3>
<p>
XML パーサーの危険な機能が公開されないようにするためには，コードを次のように変更します。
</p>
<!--XXE_GENERIC_END-->

<p><b>脆弱なコード:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>DocumentBuilder builder = df.newDocumentBuilder();

XPathFactory xPathFactory = XPathFactory.newInstance();
XPath xpath = xPathFactory.newXPath();
XPathExpression xPathExpr = xpath.compile("/somepath/text()");

xPathExpr.evaluate(new InputSource(inputStream));</code></pre>
</p>
<br/>
<p>
次のスニペットでは，利用可能な2つの解決策を示しています。1つまたは両方の機能を設定します。
</p>

<p><b>"Secure processing" モードを使用した解決策:</b></p>
<p>
この設定により，サービス拒否攻撃とリモートファイルアクセスから保護されます。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();
df.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
DocumentBuilder builder = df.newDocumentBuilder();

[...]

xPathExpr.evaluate( builder.parse(inputStream) );</code></pre>
</p>

<p><b>DTD を無効にする解決策:</b></p>
<p>
DTD を無効にすることによって，ほとんどすべての XXE 攻撃 が防止されます。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();
spf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
DocumentBuilder builder = df.newDocumentBuilder();

[...]

xPathExpr.evaluate( builder.parse(inputStream) );</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<!--XXE_GENERIC_START-->
<a target="_blank" href="https://cwe.mitre.org/data/definitions/611.html">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a target="_blank" href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_Entity_Expansion">WS-Attacks.org: XML Entity Expansion</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_External_Entity_DOS">WS-Attacks.org: XML External Entity DOS</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a target="_blank" href="https://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html">Identifying XML External Entity vulnerability (XXE)</a><br/>
<!--XXE_GENERIC_END-->
<a target="_blank" href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#XPathExpression">XML External Entity (XXE) Prevention Cheat Sheet</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="XXE_SAXPARSER"></a>
        <h2 class="page-header">
            XXE に脆弱な XML 解析 (SAXParser)
            <a href="#XXE_SAXPARSER" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>XXE_SAXPARSER</tt></small></em></p>

        
            
<!--XXE_GENERIC_START-->
<h3>攻撃</h3>
<p>信頼されていないソースから受け取った XML を処理しているときに，XML パーサーが XML エンティティをサポートしていると XML 外部エンティティ (XXE:XML External Entity) 攻撃が発生する可能性があります。</p>
<p><b>リスク 1: ローカルファイルの内容の暴露 (XXE: <u>X</u>ML e<u>X</u>ternal <u>E</u>ntity)</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre>
</p>
<b>リスク 2: サービス拒否 (XEE: <u>X</u>ml <u>E</u>ntity <u>E</u>xpansion)</b>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol &quot;lol&quot;&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
 &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;
 &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
[...]
 &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre>
</p>

<h3>解決策</h3>
<p>
XML パーサーの危険な機能が公開されないようにするためには，コードを次のように変更します。
</p>
<!--XXE_GENERIC_END-->

<p><b>脆弱なコード:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>SAXParser parser = SAXParserFactory.newInstance().newSAXParser();

parser.parse(inputStream, customHandler);</code></pre>
</p>
<br/>
<p>
次のスニペットでは，利用可能な2つの解決策を示しています。1つまたは両方の機能を設定します。
</p>

<p><b>"Secure processing" モードを使用した解決策:</b></p>
<p>
この設定により，サービス拒否攻撃とリモートファイルアクセスから保護されます。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>SAXParserFactory spf = SAXParserFactory.newInstance();
spf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
SAXParser parser = spf.newSAXParser();

parser.parse(inputStream, customHandler);</code></pre>
</p>

<p><b>DTD を無効にする解決策:</b></p>
<p>
DTD を無効にすることによって，ほとんどすべての XXE 攻撃 が防止されます。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>SAXParserFactory spf = SAXParserFactory.newInstance();
spf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
SAXParser parser = spf.newSAXParser();

parser.parse(inputStream, customHandler);</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<!--XXE_GENERIC_START-->
<a target="_blank" href="https://cwe.mitre.org/data/definitions/611.html">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a target="_blank" href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_Entity_Expansion">WS-Attacks.org: XML Entity Expansion</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_External_Entity_DOS">WS-Attacks.org: XML External Entity DOS</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a target="_blank" href="https://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html">Identifying XML External Entity vulnerability (XXE)</a><br/>
<!--XXE_GENERIC_END-->
<a target="_blank" href="https://xerces.apache.org/xerces-j/features.html">Xerces complete features list</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="XXE_XMLREADER"></a>
        <h2 class="page-header">
            XXE に脆弱な XML 解析 (XMLReader)
            <a href="#XXE_XMLREADER" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>XXE_XMLREADER</tt></small></em></p>

        
            
<!--XXE_GENERIC_START-->
<h3>攻撃</h3>
<p>信頼されていないソースから受け取った XML を処理しているときに，XML パーサーが XML エンティティをサポートしていると XML 外部エンティティ (XXE:XML External Entity) 攻撃が発生する可能性があります。</p>
<p><b>リスク 1: ローカルファイルの内容の暴露 (XXE: <u>X</u>ML e<u>X</u>ternal <u>E</u>ntity)</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre>
</p>
<b>リスク 2: サービス拒否 (XEE: <u>X</u>ml <u>E</u>ntity <u>E</u>xpansion)</b>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol &quot;lol&quot;&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
 &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;
 &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
[...]
 &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre>
</p>

<h3>解決策</h3>
<p>
XML パーサーの危険な機能が公開されないようにするためには，コードを次のように変更します。
</p>
<!--XXE_GENERIC_END-->

<p><b>脆弱なコード:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>XMLReader reader = XMLReaderFactory.createXMLReader();
reader.setContentHandler(customHandler);
reader.parse(new InputSource(inputStream));</code></pre>
</p>
<br/>
<p>
次のスニペットでは，利用可能な2つの解決策を示しています。1つまたは両方の機能を設定します。
</p>

<p><b>"Secure processing" モードを使用した解決策:</b></p>
<p>
この設定により，サービス拒否攻撃とリモートファイルアクセスから保護されます。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>XMLReader reader = XMLReaderFactory.createXMLReader();
reader.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
reader.setContentHandler(customHandler);

reader.parse(new InputSource(inputStream));</code></pre>
</p>

<p><b>DTD を無効にする解決策:</b></p>
<p>
DTD を無効にすることによって，ほとんどすべての XXE 攻撃 が防止されます。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>XMLReader reader = XMLReaderFactory.createXMLReader();
reader.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
reader.setContentHandler(customHandler);

reader.parse(new InputSource(inputStream));</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<!--XXE_GENERIC_START-->
<a target="_blank" href="https://cwe.mitre.org/data/definitions/611.html">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a target="_blank" href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_Entity_Expansion">WS-Attacks.org: XML Entity Expansion</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_External_Entity_DOS">WS-Attacks.org: XML External Entity DOS</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a target="_blank" href="https://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html">Identifying XML External Entity vulnerability (XXE)</a><br/>
<!--XXE_GENERIC_END-->
<a target="_blank" href="https://xerces.apache.org/xerces-j/features.html">Xerces complete features list</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="XXE_DOCUMENT"></a>
        <h2 class="page-header">
            XXE に脆弱な XML 解析 (DocumentBuilder)
            <a href="#XXE_DOCUMENT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>XXE_DOCUMENT</tt></small></em></p>

        
            
<!--XXE_GENERIC_START-->
<h3>攻撃</h3>
<p>信頼されていないソースから受け取った XML を処理しているときに，XML パーサーが XML エンティティをサポートしていると XML 外部エンティティ (XXE:XML External Entity) 攻撃が発生する可能性があります。</p>
<p><b>リスク 1: ローカルファイルの内容の暴露 (XXE: <u>X</u>ML e<u>X</u>ternal <u>E</u>ntity)</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre>
</p>
<b>リスク 2: サービス拒否 (XEE: <u>X</u>ml <u>E</u>ntity <u>E</u>xpansion)</b>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol &quot;lol&quot;&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
 &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;
 &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
[...]
 &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre>
</p>

<h3>解決策</h3>
<p>
XML パーサーの危険な機能が公開されないようにするためには，コードを次のように変更します。
</p>
<!--XXE_GENERIC_END-->

<p><b>脆弱なコード:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();

Document doc = db.parse(input);</code></pre>
</p>
<br/>
<p>
次のスニペットでは，利用可能な2つの解決策を示しています。1つまたは両方の機能を設定します。
</p>

<p><b>"Secure processing" モードを使用した解決策:</b></p>
<p>
この設定により，サービス拒否攻撃とリモートファイルアクセスから保護されます。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
DocumentBuilder db = dbf.newDocumentBuilder();

Document doc = db.parse(input);</code></pre>
</p>

<p><b>DTD を無効にする解決策:</b></p>
<p>
DTD を無効にすることによって，ほとんどすべての XXE 攻撃 が防止されます。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
DocumentBuilder db = dbf.newDocumentBuilder();

Document doc = db.parse(input);</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<!--XXE_GENERIC_START-->
<a target="_blank" href="https://cwe.mitre.org/data/definitions/611.html">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a target="_blank" href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_Entity_Expansion">WS-Attacks.org: XML Entity Expansion</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_External_Entity_DOS">WS-Attacks.org: XML External Entity DOS</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a target="_blank" href="https://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html">Identifying XML External Entity vulnerability (XXE)</a><br/>
<!--XXE_GENERIC_END-->
<a target="_blank" href="http://xerces.apache.org/xerces2-j/features.html">Xerces2 complete features list</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="XXE_DTD_TRANSFORM_FACTORY"></a>
        <h2 class="page-header">
            XXE に脆弱な XML 解析 (TransformerFactory)
            <a href="#XXE_DTD_TRANSFORM_FACTORY" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>XXE_DTD_TRANSFORM_FACTORY</tt></small></em></p>

        
            
<!--XXE_GENERIC_START-->
<h3>攻撃</h3>
<p>信頼されていないソースから受け取った XML を処理しているときに，XML パーサーが XML エンティティをサポートしていると XXE (XML External Entity) 攻撃が発生する可能性があります。</p>
<p><b>リスク 1: ローカルファイルの内容の暴露 (XXE: <u>X</u>ML E<u>x</u>ternal <u>E</u>ntity)</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre>
</p>
<b>リスク 2: サービス拒否 (XEE: <u>X</u>ML <u>E</u>ntity <u>E</u>xpansion)</b>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol &quot;lol&quot;&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
 &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;
 &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
[...]
 &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre>
</p>

<h3>解決策</h3>
<p>
XML パーサーの危険な機能が公開されないようにするためには，コードを次のように変更します。
</p>
<!--XXE_GENERIC_END-->

<p><b>脆弱なコード:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Transformer transformer = TransformerFactory.newInstance().newTransformer();
transformer.transform(input, result);</code></pre>
</p>
<br/>
<p>
次のスニペットでは，利用可能な2つの解決策を示しています。1つまたは両方の機能を設定します。
</p>

<p><b>"Secure processing" モードを使用した解決策:</b></p>
<p>
This setting will protect you against remote file access but not denial of service.
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>TransformerFactory factory = TransformerFactory.newInstance();
factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "all");
factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "all");

Transformer transformer = factory.newTransformer();
transformer.setOutputProperty(OutputKeys.INDENT, "yes");

transformer.transform(input, result);</code></pre>
</p>

<p><b>DTD を無効にする解決策:</b></p>
<p>
This setting will protect you against remote file access but not denial of service.
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>TransformerFactory factory = TransformerFactory.newInstance();
factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);

Transformer transformer = factory.newTransformer();
transformer.setOutputProperty(OutputKeys.INDENT, "yes");

transformer.transform(input, result);</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<!--XXE_GENERIC_START-->
<a target="_blank" href="https://cwe.mitre.org/data/definitions/611.html">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a target="_blank" href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_Entity_Expansion">WS-Attacks.org: XML Entity Expansion</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_External_Entity_DOS">WS-Attacks.org: XML External Entity DOS</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a target="_blank" href="https://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html">Identifying XML External Entity vulnerability (XXE)</a><br/>
<!--XXE_GENERIC_END-->
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="XXE_XSLT_TRANSFORM_FACTORY"></a>
        <h2 class="page-header">
            XXE に脆弱な XSLT 解析 (TransformerFactory)
            <a href="#XXE_XSLT_TRANSFORM_FACTORY" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>XXE_XSLT_TRANSFORM_FACTORY</tt></small></em></p>

        
            
<!--XXE_GENERIC_START-->
<h3>攻撃</h3>
<p>信頼されていないソースから受け取った XSLT を処理しているときに，XSLT パーサーが 外部エンティティをサポートしていると XXE (XSLT External Entity) 攻撃が発生する可能性があります。</p>
<p><b>リスク: ローカルファイルの内容の暴露 (XXE: <u>X</u>ML E<u>x</u>ternal <u>E</u>ntity)</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;
   &lt;xsl:template match=&quot;/&quot;&gt;
       &lt;xsl:value-of select=&quot;document(&apos;/etc/passwd&apos;)&quot;&gt;
   &lt;/xsl:value-of&gt;&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</code></pre>
</p>

<h3>解決策</h3>
<p>
XML パーサーの危険な機能が公開されないようにするためには，コードを次のように変更します。
</p>
<!--XXE_GENERIC_END-->

<p><b>脆弱なコード:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Transformer transformer = TransformerFactory.newInstance().newTransformer();
transformer.transform(input, result);</code></pre>
</p>
<br/>
<p>
次のスニペットでは，利用可能な2つの解決策を示しています。1つまたは両方の機能を設定します。
</p>
<p><b>"Secure processing" モードを使用した解決策:</b></p>
<p>
この設定により，リモートファイルアクセスから保護されますが，サービス拒否は保護されません。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>TransformerFactory factory = TransformerFactory.newInstance();
factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "all");
factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "all");

Transformer transformer = factory.newTransformer();
transformer.setOutputProperty(OutputKeys.INDENT, "yes");

transformer.transform(input, result);</code></pre>
</p>

<p><b>DTD を無効にする解決策:</b></p>
<p>
この設定により，リモートファイルアクセスから保護されますが，サービス拒否は保護されません。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>TransformerFactory factory = TransformerFactory.newInstance();
factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);

Transformer transformer = factory.newTransformer();
transformer.setOutputProperty(OutputKeys.INDENT, "yes");

transformer.transform(input, result);</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<!--XXE_GENERIC_START-->
<a target="_blank" href="https://cwe.mitre.org/data/definitions/611.html">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a target="_blank" href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_Entity_Expansion">WS-Attacks.org: XML Entity Expansion</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_External_Entity_DOS">WS-Attacks.org: XML External Entity DOS</a><br/>
<a target="_blank" href="https://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a target="_blank" href="https://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html">Identifying XML External Entity vulnerability (XXE)</a><br/>
<!--XXE_GENERIC_END-->
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="XPATH_INJECTION"></a>
        <h2 class="page-header">
            潜在的な XPath インジェクション
            <a href="#XPATH_INJECTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>XPATH_INJECTION</tt></small></em></p>

        
            
<p>
XPath インジェクションのリスクは，SQL インジェクションに似ています。XPath クエリーに信頼できないユーザー入力が含まれていると，完全なデータソースが暴露される可能性があります。
これにより，攻撃者は権限のないデータにアクセスしたり，標的の XML を悪意をもって改ざんできます。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-39: XPath Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/643.html">CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection')</a><br/>
<a target="_blank" href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61407250">CERT: IDS09-J. Prevent XPath Injection (archive)</a><br/>
<a target="_blank" href="https://media.blackhat.com/bh-eu-12/Siddharth/bh-eu-12-Siddharth-Xpath-WP.pdf">Black Hat Europe 2012: Hacking XPath 2.0</a><br/>
<a target="_blank" href="https://www.balisage.net/Proceedings/vol7/html/Vlist02/BalisageVol7-Vlist02.html">Balisage.net: XQuery Injection</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="STRUTS1_ENDPOINT"></a>
        <h2 class="page-header">
            Struts 1 アクション を発見
            <a href="#STRUTS1_ENDPOINT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>STRUTS1_ENDPOINT</tt></small></em></p>

        
            
<p>このクラスは Struts 1 のアクションです。</p>
<p>リクエストがこのコントローラーにルーティングされると，HTTP パラメーター を含む Form オブジェクトが自動的にインスタンス化されます。
これらのパラメーターが安全に使用されているかを確認するためにレビューすべきです。</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="STRUTS2_ENDPOINT"></a>
        <h2 class="page-header">
            Struts 2 のエンドポイントを発見
            <a href="#STRUTS2_ENDPOINT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>STRUTS2_ENDPOINT</tt></small></em></p>

        
            
<p>Struts 2 では，エンドポイントは Plain Old Java Objects (POJO) です。つまり，インタフェース/クラスを実装/継承する必要がないということです。</p>
<p>リクエストがそのコントローラー (選択されたクラス) にルーティングされると与えられた HTTP パラメーターが自動的にクラスのセッターにマッピングされます。
そのため，フォームにそれらの値が含まれていなくても，このクラスのすべてのセッターは信頼できない入力として見なすべきです。
オブジェクトにそのようなセッターがあるかぎり，攻撃者はリクエストに追加の値を与えるだけで，オブジェクトに設定できます。
これらのパラメーターが安全に使用されているかを確認するためにレビューすべきです。</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SPRING_ENDPOINT"></a>
        <h2 class="page-header">
            Spring のエンドポイントを発見
            <a href="#SPRING_ENDPOINT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SPRING_ENDPOINT</tt></small></em></p>

        
            
<p>このクラスは Spring コントローラーです。
<code>RequestMapping</code> (そのショートカットアノテーション <code>GetMapping</code>，<code>PostMapping</code>，<code>PutMapping</code>，
<code>DeleteMapping</code>，<code>PatchMapping</code>) というアノテーションが付けられたすべてのメソッドは，リモートから到達可能です。
リモートに公開したメソッドが潜在的な攻撃者に公開しても安全であるかを確認するために，このクラスを分析するべきです。</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SPRING_CSRF_PROTECTION_DISABLED"></a>
        <h2 class="page-header">
            Spring CSRF 保護の無効化
            <a href="#SPRING_CSRF_PROTECTION_DISABLED" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SPRING_CSRF_PROTECTION_DISABLED</tt></small></em></p>

        
            
<p>Spring Security の CSRF 保護を無効にすることは，標準の Web アプリケーションでは安全ではありません。</p>
<p>この保護を無効にすることが有効なユースケースは，ブラウザー以外のクライアントによってだけ使用されることが保証されている状態変更操作を公開するサービスです。</p>
<p>
    <b>安全でない設定:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable();
    }
}</code></pre>
</p>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html#when-to-use-csrf-protection">Spring Security Official Documentation: When to use CSRF protection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29">OWASP: Cross-Site Request Forgery</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet">OWASP: CSRF Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/352.html">CWE-352: Cross-Site Request Forgery (CSRF)</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING"></a>
        <h2 class="page-header">
            Spring の制限のない RequestMapping による CSRF
            <a href="#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING</tt></small></em></p>

        
            
<p><code>RequestMapping</code> というアノテーションが付けられたメソッドは，デフォルトですべての HTTP リクエストメソッドにマッピングされます。
しかし，Spring Security の CSRF 保護は HTTP リクエストメソッド <code>GET</code>，<code>HEAD</code>，<code>TRACE</code>，<code>OPTIONS</code>
に対して有効になっていません (トークンが漏洩する可能性があるため)。
したがって，<code>RequestMapping</code> でアノテーションされ，マッピングを絞り込まない状態変更メソッド
<code>POST</code>，<code>PUT</code>，<code>DELETE</code>，<code>PATCH</code> は CSRF 攻撃に対して脆弱です。</p>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>@Controller
public class UnsafeController {

    @RequestMapping("/path")
    public void writeData() {
        // このメソッド内で実行される状態変更操作
    }
}</code></pre>
</p>
<p>
    <b>解決策 (Spring Framework 4.3 以降):</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>@Controller
public class SafeController {

    /**
     * For methods without side-effects use @GetMapping.
     */
    @GetMapping("/path")
    public String readData() {
        // このメソッド内で状態変更操作は実行されない
        return "";
    }

    /**
     * For state-changing methods use either @PostMapping, @PutMapping, @DeleteMapping, or @PatchMapping.
     */
    @PostMapping("/path")
    public void writeData() {
        // このメソッド内で実行される状態変更操作
    }
}</code></pre>
</p>
<p>
    <b>解決策 (Spring Framework 4.3 以前):</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>@Controller
public class SafeController {

    /**
     * For methods without side-effects use either
     * RequestMethod.GET, RequestMethod.HEAD, RequestMethod.TRACE, or RequestMethod.OPTIONS.
     */
    @RequestMapping(value = "/path", method = RequestMethod.GET)
    public String readData() {
        // このメソッド内で状態変更操作は実行されない
        return "";
    }

    /**
     * For state-changing methods use either
     * RequestMethod.POST, RequestMethod.PUT, RequestMethod.DELETE, or RequestMethod.PATCH.
     */
    @RequestMapping(value = "/path", method = RequestMethod.POST)
    public void writeData() {
        // このメソッド内で実行される状態変更操作
    }
}</code></pre>
</p>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html#csrf-use-proper-verbs">Spring Security Official Documentation: Use proper HTTP verbs (CSRF protection)</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29">OWASP: Cross-Site Request Forgery</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet">OWASP: CSRF Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/352.html">CWE-352: Cross-Site Request Forgery (CSRF)</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="CUSTOM_INJECTION"></a>
        <h2 class="page-header">
            潜在的インジェクション (独自)
            <a href="#CUSTOM_INJECTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>CUSTOM_INJECTION</tt></small></em></p>

        
            
<p>
特定されたメソッドはインジェクションの影響を受けやすいです。入力を検証して，適切にエスケープするべきです。
</p>

<p>
    <b>脆弱なコード:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>SqlUtil.execQuery("select * from UserEntity t where id = " + parameterInput);</code></pre>
</p>
<p>
<a target="_blank" href="https://github.com/find-sec-bugs/find-sec-bugs/wiki/Custom-signatures">カスタムシグネチャを設定する方法</a> の詳細な手順についてはオンライン wiki を参照してください。
</p>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SQL_INJECTION"></a>
        <h2 class="page-header">
            潜在的な SQL インジェクション
            <a href="#SQL_INJECTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SQL_INJECTION</tt></small></em></p>

        
            
<p>
SQL クエリーに含まれる入力値は安全に渡す必要があります。プリペアードステートメントのバインド変数を使用すると SQL インジェクションのリスクを容易に軽減できます。
プリペアードステートメントの代わりに各パラメーターを手動でエスケープすることもできます。
</p>
<p>
    <b>脆弱なコード:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>createQuery("select * from User where id = '"+inputId+"'");
</code></pre>
</p>
<p>
    <b>解決策:</b><br/>

    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>import org.owasp.esapi.Encoder;

createQuery("select * from User where id = '"+Encoder.encodeForSQL(inputId)+"'");
</code></pre>
</p>
<br/>
<p>
<b>参考文献 (SQL インジェクション)</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SQL_INJECTION_TURBINE"></a>
        <h2 class="page-header">
            Turbine による潜在的な SQL インジェクション
            <a href="#SQL_INJECTION_TURBINE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SQL_INJECTION_TURBINE</tt></small></em></p>

        
            
<p>
SQL クエリーに含まれる入力値は安全に渡す必要があります。プリペアードステートメントのバインド変数を使用すると SQL インジェクションのリスクを容易に軽減できます。
Turbine API は，Java コードを使用してクエリーを作成する DSL を提供します。
</p>
<p>
    <b>脆弱なコード:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>List&lt;Record&gt; BasePeer.executeQuery( "select * from Customer where id=" + inputId );
</code></pre>
</p>
<p>
    <b>解決策 (Criteria DSL を使用):</b><br/>

    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Criteria c = new Criteria();
c.add( CustomerPeer.ID, inputId );

List&lt;Customer&gt; customers = CustomerPeer.doSelect( c );
</code></pre>

    <b>解決策 (特殊なメソッドを使用):</b><br/>

<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Customer customer = CustomerPeer.retrieveByPK( new NumberKey( inputId ) );
</code></pre>

    <b>解決策 (OWASP Encoder を使用):</b><br/>

    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>import org.owasp.esapi.Encoder;

BasePeer.executeQuery("select * from Customer where id = '"+Encoder.encodeForSQL(inputId)+"'");
</code></pre>
</p>
<br/>
<p>
<b>参考文献 (Turbine)</b><br/>
<a target="_blank" href="https://turbine.apache.org/turbine/turbine-2.1/howto/criteria-howto.html">Turbine Documentation: Criteria Howto</a><br/>
<b>参考文献 (SQL インジェクション)</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SQL_INJECTION_HIBERNATE"></a>
        <h2 class="page-header">
            潜在的な SQL/HQL インジェクション (Hibernate)
            <a href="#SQL_INJECTION_HIBERNATE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SQL_INJECTION_HIBERNATE</tt></small></em></p>

        
            
<p>
SQL クエリーに含まれる入力値は安全に渡す必要があります。プリペアードステートメントのバインド変数を使用すると SQL インジェクションのリスクを容易に軽減できます。
プリペアードステートメントの代わりに Hibernate Criteria を使用することもできます。
</p>
<p>
    <b>脆弱なコード:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Session session = sessionFactory.openSession();
Query q = session.createQuery("select t from UserEntity t where id = " + input);
q.execute();</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Session session = sessionFactory.openSession();
Query q = session.createQuery("select t from UserEntity t where id = :userId");
q.setString("userId",input);
q.execute();</code></pre>
</p>
<p>
    <b>動的クエリーの解決策 (Hibernate Criteria を使用):</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Session session = sessionFactory.openSession();
Query q = session.createCriteria(UserEntity.class)
    .add( Restrictions.like("id", input) )
    .list();
q.execute();</code></pre>
</p>
<br/>
<p>
<b>参考文献 (Hibernate)</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/564.html">CWE-564: SQL Injection: Hibernate</a><br/>
<a target="_blank" href="https://docs.jboss.org/hibernate/orm/3.3/reference/en/html/querycriteria.html">Hibernate Documentation: Query Criteria</a><br/>
<a target="_blank" href="https://docs.jboss.org/hibernate/orm/3.2/api/org/hibernate/Query.html">Hibernate Javadoc: Query Object</a><br/>
<a target="_blank" href="https://blog.h3xstream.com/2014/02/hql-for-pentesters.html">HQL for pentesters</a>: Guideline to test if the suspected code is exploitable.<br/>

<b>参考文献 (SQL インジェクション)</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SQL_INJECTION_JDO"></a>
        <h2 class="page-header">
            潜在的な SQL/JDOQL インジェクション (JDO)
            <a href="#SQL_INJECTION_JDO" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SQL_INJECTION_JDO</tt></small></em></p>

        
            
<p>
SQL クエリーに含まれる入力値は安全に渡す必要があります。プリペアードステートメントのバインド変数を使用すると SQL インジェクションのリスクを容易に軽減できます。
</p>
<p>
    <b>脆弱なコード:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>PersistenceManager pm = getPM();

Query q = pm.newQuery("select * from Users where name = " + input);
q.execute();</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>PersistenceManager pm = getPM();

Query q = pm.newQuery("select * from Users where name = nameParam");
q.declareParameters("String nameParam");
q.execute(input);</code></pre>
</p>
<br/>
<p>
<b>参考文献 (JDO)</b><br/>
<a target="_blank" href="https://db.apache.org/jdo/object_retrieval.html">JDO: Object Retrieval</a><br/>
<b>参考文献 (SQL インジェクション)</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SQL_INJECTION_JPA"></a>
        <h2 class="page-header">
            潜在的な SQL/JPQL インジェクション (JPA)
            <a href="#SQL_INJECTION_JPA" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SQL_INJECTION_JPA</tt></small></em></p>

        
            
<p>
SQL クエリーに含まれる入力値は安全に渡す必要があります。プリペアードステートメントのバインド変数を使用すると SQL インジェクションのリスクを容易に軽減できます。
</p>
<p>
    <b>脆弱なコード:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>EntityManager pm = getEM();

TypedQuery&lt;UserEntity&gt; q = em.createQuery(
    String.format("select * from Users where name = %s", username),
    UserEntity.class);

UserEntity res = q.getSingleResult();</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>TypedQuery&lt;UserEntity&gt; q = em.createQuery(
    "select * from Users where name = usernameParam",UserEntity.class)
    .setParameter("usernameParam", username);

UserEntity res = q.getSingleResult();</code></pre>
</p>
<br/>
<p>
<b>参考文献 (JPA)</b><br/>
<a target="_blank" href="https://docs.oracle.com/javaee/6/tutorial/doc/bnbrg.html">The Java EE 6 Tutorial: Creating Queries Using the Java Persistence Query Language</a><br/>
<b>参考文献 (SQL インジェクション)</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SQL_INJECTION_SPRING_JDBC"></a>
        <h2 class="page-header">
            潜在的な JDBC インジェクション (Spring JDBC)
            <a href="#SQL_INJECTION_SPRING_JDBC" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SQL_INJECTION_SPRING_JDBC</tt></small></em></p>

        
            
<p>
SQL クエリーに含まれる入力値は安全に渡す必要があります。プリペアードステートメントのバインド変数を使用すると SQL インジェクションのリスクを容易に軽減できます。
</p>

<p>
    <b>脆弱なコード:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>JdbcTemplate jdbc = new JdbcTemplate();
int count = jdbc.queryForObject("select count(*) from Users where name = '"+paramName+"'", Integer.class);
</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>JdbcTemplate jdbc = new JdbcTemplate();
int count = jdbc.queryForObject("select count(*) from Users where name = ?", Integer.class, paramName);</code></pre>
</p>
<br/>

<b>参考文献 (Spring JDBC)</b><br/>
<a target="_blank" href="https://spring.io/guides/gs/relational-data-access/">Spring Official Documentation: Data access with JDBC</a><br/>
<b>参考文献 (SQL インジェクション)</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SQL_INJECTION_JDBC"></a>
        <h2 class="page-header">
            潜在的な JDBC インジェクション
            <a href="#SQL_INJECTION_JDBC" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SQL_INJECTION_JDBC</tt></small></em></p>

        
            
<p>
SQL クエリーに含まれる入力値は安全に渡す必要があります。プリペアードステートメントのバインド変数を使用すると SQL インジェクションのリスクを容易に軽減できます。
</p>

<p>
    <b>脆弱なコード:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Connection conn = [...];
Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery("update COFFEES set SALES = "+nbSales+" where COF_NAME = '"+coffeeName+"'");</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Connection conn = [...];
conn.prepareStatement("update COFFEES set SALES = ? where COF_NAME = ?");
updateSales.setInt(1, nbSales);
updateSales.setString(2, coffeeName);</code></pre>
</p>
<br/>

<b>参考文献 (JDBC)</b><br/>
<a target="_blank" href="https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html">Oracle Documentation: The Java Tutorials &gt; Prepared Statements</a><br/>
<b>参考文献 (SQL インジェクション)</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SCALA_SQL_INJECTION_SLICK"></a>
        <h2 class="page-header">
            潜在的な Scala Slick インジェクション
            <a href="#SCALA_SQL_INJECTION_SLICK" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SCALA_SQL_INJECTION_SLICK</tt></small></em></p>

        
            
<p>
SQL クエリーに含まれる入力値は安全に渡す必要があります。プリペアードステートメントのバインド変数を使用すると SQL インジェクションのリスクを容易に軽減できます。
</p>

<p>
    <b>脆弱なコード:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>db.run {
  sql"select * from people where name = '#$value'".as[Person]
}</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>db.run {
  sql"select * from people where name = $value".as[Person]
}</code></pre>
</p>
<br/>

<b>参考文献 (SQL インジェクション)</b></b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SCALA_SQL_INJECTION_ANORM"></a>
        <h2 class="page-header">
            潜在的な Scala Anorm インジェクション
            <a href="#SCALA_SQL_INJECTION_ANORM" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SCALA_SQL_INJECTION_ANORM</tt></small></em></p>

        
            
<p>
SQL クエリーに含まれる入力値は安全に渡す必要があります。プリペアードステートメントのバインド変数を使用すると SQL インジェクションのリスクを容易に軽減できます。
</p>

<p>
    <b>脆弱なコード:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>val peopleParser = Macro.parser[Person]("id", "name", "age")

DB.withConnection { implicit c =>
  val people: List[Person] = SQL("select * from people where name = '" + value + "'").as(peopleParser.*)
}</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>val peopleParser = Macro.parser[Person]("id", "name", "age")

DB.withConnection { implicit c =>
  val people: List[Person] = SQL"select * from people where name = $value".as(peopleParser.*)
}</code></pre>
</p>
<br/>

<b>参考文献 (SQL インジェクション)</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SQL_INJECTION_ANDROID"></a>
        <h2 class="page-header">
            潜在的な Android SQL インジェクション
            <a href="#SQL_INJECTION_ANDROID" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SQL_INJECTION_ANDROID</tt></small></em></p>

        
            
<p>
SQL クエリーに含まれる入力値は安全に渡す必要があります。プリペアードステートメントのバインド変数を使用すると SQL インジェクションのリスクを容易に軽減できます。
</p>

<p>
    <b>脆弱なコード:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>String query = "SELECT * FROM  messages WHERE uid= '"+userInput+"'" ;
Cursor cursor = this.getReadableDatabase().rawQuery(query,null);</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>String query = "SELECT * FROM  messages WHERE uid= ?" ;
Cursor cursor = this.getReadableDatabase().rawQuery(query,new String[] {userInput});</code></pre>
</p>
<br/>

<b>参考文献 (Android SQLite)</b><br/>
<a target="_blank" href="http://www.informit.com/articles/article.aspx?p=2268753&seqNum=5">InformIT.com: Practical Advice for Building Secure Android Databases in SQLite</a><br/>
<a target="_blank" href="https://www.packtpub.com/books/content/knowing-sql-injection-attacks-and-securing-our-android-applications-them">Packtpub.com: Knowing the SQL-injection attacks and securing our Android applications from them</a><br/>
<a target="_blank" href="https://books.google.ca/books?id=SXlMAQAAQBAJ&lpg=PR1&pg=PA64#v=onepage&q&f=false">Android Database Support (Enterprise Android: Programming Android Database Applications for the Enterprise)</a><br/>
<a target="_blank" href="https://stackoverflow.com/a/29797229/89769">Safe example of Insert, Select, Update and Delete queries provided by Suragch</a><br/>

<b>参考文献 (SQL インジェクション)</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="LDAP_INJECTION"></a>
        <h2 class="page-header">
            潜在的な LDAP インジェクション
            <a href="#LDAP_INJECTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>LDAP_INJECTION</tt></small></em></p>

        
            
<p>
SQL と同様に，LDAP クエリーに渡されるすべての入力は安全に渡す必要があります。残念ながら，LDAP には SQL のようなプリペアードステートメントインタフェースがありません。
そのため，LDAP インジェクションに対する一次防御は，LDAP クエリーに含める前に信頼できないデータを十分に検証することです。
</p>
<p>
    <b>リスクのあるコード:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>NamingEnumeration&lt;SearchResult&gt; answers = context.search("dc=People,dc=example,dc=com",
        "(uid=" + username + ")", ctrls);</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246947/LDAP%20Injection">WASC-29: LDAP Injection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/90.html">CWE-90: Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</a><br/>
<a target="_blank" href="https://www.veracode.com/security/ldap-injection">LDAP Injection Guide: Learn How to Detect LDAP Injections and Improve LDAP Security</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SCRIPT_ENGINE_INJECTION"></a>
        <h2 class="page-header">
            スクリプトエンジン使用時の潜在的なコードインジェクション
            <a href="#SCRIPT_ENGINE_INJECTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SCRIPT_ENGINE_INJECTION</tt></small></em></p>

        
            
<p>
動的なコードが評価されています。コードの構築を慎重に分析するべきです。悪意のあるコードの実行は，データ漏洩やオペレーティングシステムが危険にさらされる可能性があります。
</p>
<p>
ユーザーコードの評価を意図しているなら，適切なサンドボックスを用意すべきです (参考文献を参照)。
</p>

<p><b>リスクのあるコード:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public void runCustomTrigger(String script) {
    ScriptEngineManager factory = new ScriptEngineManager();
    ScriptEngine engine = factory.getEngineByName("JavaScript");

    engine.eval(script); //Bad things can happen here.
}</code></pre>
</p>

<p><b>解決策:</b></p>
<p>
Cloudbees Rhino Sandbox ライブラリーを使用した Javascript コードの安全な評価。<br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public void runCustomTrigger(String script) {
    SandboxContextFactory contextFactory = new SandboxContextFactory();
    Context context = contextFactory.makeContext();
    contextFactory.enterContext(context);
    try {
        ScriptableObject prototype = context.initStandardObjects();
        prototype.setParentScope(null);
        Scriptable scope = context.newObject(prototype);
        scope.setPrototype(prototype);

        context.evaluateString(scope,script, null, -1, null);
    } finally {
        context.exit();
    }
}</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://github.com/cloudbees/rhino-sandbox">Cloudbees Rhino Sandbox</a>: Utility to create sandbox with Rhino (block access to all classes)<br/>
<a target="_blank" href="https://codeutopia.net/blog/2009/01/02/sandboxing-rhino-in-java/">CodeUtopia.net: Sandboxing Rhino in Java</a><br/>
<a target="_blank" href="https://blog.h3xstream.com/2014/11/remote-code-execution-by-design.html">Remote Code Execution .. by design</a>: Example of malicious payload. The samples given could be used to test sandboxing rules.<br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/94.html">CWE-94: Improper Control of Generation of Code ('Code Injection')</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/95.html">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SPEL_INJECTION"></a>
        <h2 class="page-header">
            Spring 式使用時の潜在的なコードインジェクション
            <a href="#SPEL_INJECTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SPEL_INJECTION</tt></small></em></p>

        
            
<p>
Spring 式は，動的な値で構築されています。フィルタされていない値が危険なコード評価になることを避けるために値の発生源を検証すべきです。
</p>
<p><b>リスクのあるコード:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public void parseExpressionInterface(Person personObj,String property) {

        ExpressionParser parser = new SpelExpressionParser();

        //Unsafe if the input is control by the user..
        Expression exp = parser.parseExpression(property+" == 'Albert'");

        StandardEvaluationContext testContext = new StandardEvaluationContext(personObj);
        boolean result = exp.getValue(testContext, Boolean.class);
[...]</code></pre>
</p>
<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/94.html">CWE-94: Improper Control of Generation of Code ('Code Injection')</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/95.html">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')</a><br/>
    <a target="_blank" href="https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html">Spring Expression Language (SpEL) - Official Documentation</a><br/>
    <a target="_blank" href="https://www.mindedsecurity.com/fileshare/ExpressionLanguageInjection.pdf">Minded Security: Expression Language Injection</a><br/>
    <a target="_blank" href="https://blog.h3xstream.com/2014/11/remote-code-execution-by-design.html">Remote Code Execution .. by design</a>: Example of malicious payload. The samples given could be used to test sandboxing rules.<br/>
    <a target="_blank" href="https://gosecure.net/2018/05/15/beware-of-the-magic-spell-part-1-cve-2018-1273/">Spring Data-Commons: (CVE-2018-1273)</a><br/>
    <a target="_blank" href="https://gosecure.net/2018/05/17/beware-of-the-magic-spell-part-2-cve-2018-1260/">Spring OAuth2: CVE-2018-1260</a>
</p>


        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="EL_INJECTION"></a>
        <h2 class="page-header">
            式言語 (EL) 使用時の潜在的なコードインジェクション
            <a href="#EL_INJECTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>EL_INJECTION</tt></small></em></p>

        
            
<p>
式は動的な値で構築されています。フィルタされていない値が危険なコード評価になることを避けるために値の発生源を検証すべきです。
</p>
<p><b>リスクのあるコード:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public void evaluateExpression(String expression) {
    FacesContext context = FacesContext.getCurrentInstance();
    ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();
    ELContext elContext = context.getELContext();
    ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);
    return (String) vex.getValue(elContext);
}</code></pre>
</p>
<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="http://blog.mindedsecurity.com/2015/11/reliable-os-shell-with-el-expression.html">Minded Security: Abusing EL for executing OS commands</a><br/>
    <a target="_blank" href="https://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html">The Java EE 6 Tutorial: Expression Language</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/94.html">CWE-94: Improper Control of Generation of Code ('Code Injection')</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/95.html">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')</a><br/>
    <a target="_blank" href="https://www.mindedsecurity.com/fileshare/ExpressionLanguageInjection.pdf">Minded Security: Expression Language Injection</a><br/>
    <a target="_blank" href="http://danamodio.com/appsec/research/spring-remote-code-with-expression-language-injection/">Dan Amodio's blog: Remote Code with Expression Language Injection</a><br/>
    <a target="_blank" href="https://blog.h3xstream.com/2014/11/remote-code-execution-by-design.html">Remote Code Execution .. by design</a>: Example of malicious payload. The samples given could be used to test sandboxing rules.<br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SEAM_LOG_INJECTION"></a>
        <h2 class="page-header">
            Seam ロギング呼び出しでの潜在的なコードインジェクション
            <a href="#SEAM_LOG_INJECTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SEAM_LOG_INJECTION</tt></small></em></p>

        
            
<p>
Seam Logging API は，ログメッセージに Bean プロパティを取り込むための式言語をサポートしています。
式言語は望まれていないコードの実行元になることもあります。
</p>
<p>
このコンテキストでは，式は動的な値で構築されています。フィルタされていない値が危険なコード評価になることを避けるために値の発生源を検証すべきです。
</p>
<p><b>リスクのあるコード:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public void logUser(User user) {
    log.info("Current logged in user : " + user.getUsername());
    //...
}</code></pre>
</p>
<p><b>解決策:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public void logUser(User user) {
    log.info("Current logged in user : #0", user.getUsername());
    //...
}</code></pre>
</p>
<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="https://issues.jboss.org/browse/JBSEAM-5130">JBSEAM-5130: Issue documenting the risk</a><br/>
    <a target="_blank" href="https://docs.jboss.org/seam/2.3.1.Final/reference/html_single/#d0e4185">JBoss Seam: Logging (Official documentation)</a><br/>
    <a target="_blank" href="https://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html">The Java EE 6 Tutorial: Expression Language</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/94.html">CWE-94: Improper Control of Generation of Code ('Code Injection')</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/95.html">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')</a><br/>

</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="OGNL_INJECTION"></a>
        <h2 class="page-header">
            OGNL 式使用時の潜在的なコードインジェクション
            <a href="#OGNL_INJECTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>OGNL_INJECTION</tt></small></em></p>

        
            
<p>
式は動的な値で構築されています。フィルタされていない値が危険なコード評価になることを避けるために値の発生源を検証すべきです。
</p>
<p><b>リスクのあるコード:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public void getUserProperty(String property) {
  [...]
  //The first argument is the dynamic expression.
  return ognlUtil.getValue("user."+property, ctx, root, String.class);
}
</code></pre>
</p>
<p><b>解決策:</b></p>
<p>
一般に，OGNL 式を評価するメソッドは，ユーザー入力を受け取るべきではありません。静的構成と JSP で使用することを意図しています。
</p>
<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="https://community.saas.hpe.com/t5/Security-Research/Struts-2-OGNL-Expression-Injections/ba-p/288881">HP Enterprise: Struts 2 OGNL Expression Injections by Alvaro Mu&Atilde;&plusmn;oz</a><br/>
    <a target="_blank" href="https://blog.gdssecurity.com/labs/2017/3/27/an-analysis-of-cve-2017-5638.html">Gotham Digital Science: An Analysis Of CVE-2017-5638</a><br/>
    <a target="_blank" href="https://struts.apache.org/docs/s2-016.html">Apache Struts2: Vulnerability S2-016</a><br/>
    <a target="_blank" href="https://struts.apache.org/docs/ognl.html">Apache Struts 2 Documentation: OGNL</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="HTTP_RESPONSE_SPLITTING"></a>
        <h2 class="page-header">
            潜在的な HTTP レスポンス分割
            <a href="#HTTP_RESPONSE_SPLITTING" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>HTTP_RESPONSE_SPLITTING</tt></small></em></p>

        
            
<p>
HTTP リクエストに予期しない <code>CR</code> と <code>LF</code> 文字が含まれていると，サーバーは2つの異なる HTTP レスポンス (1つではなく) として解釈される出力ストリームで応答することがあります。
攻撃者は，2番目のレスポンスを制御し，クロスサイトスクリプティングやキャッシュポイズニング攻撃などの攻撃をしかけることができます。
OWASP によると，この問題はほぼすべての今の Java EE アプリケーションサーバーで修正されていますが，入力を検証することは依然として有効です。
このリスクが懸念されるときは，問題のプラットフォームでテストして，基礎となるプラットフォームが <code>CR</code> または <code>LF</code> 文字をヘッダーに挿入できるかどうかを確認すべきです。
この弱点は SQL インジェクションなどの優先順位よりも低いと報告されています。脆弱なプラットフォームを使用しているときは，優先度の低い警告もチェックしてください。
</p>
<br/>
<p>
<b>リスクのあるコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>String author = request.getParameter(AUTHOR_PARAMETER);
// ...
Cookie cookie = new Cookie("author", author);
response.addCookie(cookie);</code></pre>
</p>
<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="https://www.owasp.org/index.php/HTTP_Response_Splitting">OWASP: HTTP Response Splitting</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/113.html">CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')</a>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/93.html">CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')</a><br/>
</p>


        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="CRLF_INJECTION_LOGS"></a>
        <h2 class="page-header">
            ログの潜在的な CRLF インジェクション
            <a href="#CRLF_INJECTION_LOGS" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>CRLF_INJECTION_LOGS</tt></small></em></p>

        
            
<p>
信頼できないソースからのデータがロガーに入れられ，正しく無力化されていないと，攻撃者はログエントリーを偽造したり，悪意のあるコンテンツを含めることができます。
挿入された偽のエントリーは，統計を歪めたり，管理者を混乱させたり，悪意のある行為を委託するときに他の当事者を巻き込むために使用される可能性があります。
ログファイルが自動的に処理されていると，攻撃者はファイルの形式を破壊したり予期しない文字を注入してファイルを使用できなくすることができます。
攻撃者は，コードやその他のコマンドをログファイルに注入し，ログ処理ユーティリティの脆弱性 (コマンドインジェクションや XSS など) を利用することもできます。
</p>
<br/>
<p>
<b>リスクのあるコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>String val = request.getParameter("user");
String metadata = request.getParameter("metadata");
[...]
if(authenticated) {
    log.info("User " + val + " (" + metadata + ") was authenticated successfully");
}
else {
    log.info("User " + val + " (" + metadata + ") was not authenticated");
}
</code></pre>

悪意のあるユーザーがメタデータパラメーターに値を送信する可能性があります: <code>"Firefox) was authenticated successfully\r\n[INFO] User bbb (Internet Explorer"</code>。
</p>

<b>解決策:</b><br/>
<p>
手動で各パラメーターをエスケープします。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>log.info("User " + val.replaceAll("[\r\n]","") + " (" + userAgent.replaceAll("[\r\n]","") + ") was not authenticated");
</code></pre>
</p>

<p>
すべてのメッセージイベントの改行を置き換えるようにロガーサービスを設定することもできます。<a target="_blank" href="https://logback.qos.ch/manual/layouts.html#replace"><code>replace</code> 関数を使用した</a> LogBack の設定例を示します。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;pattern&gt;%-5level - %replace(%msg){'[\r\n]', ''}%n&lt;/pattern&gt;
</code></pre>
</p>

<p>
最後に，改行をスペースで書き換えるロガー実装を使用することができます。
<a target="_blank" href="https://github.com/javabeanz/owasp-security-logging">OWASP Security Logging</a> プロジェクトには，LogBack と Log4j の実装があります。
</p>

<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/117.html">CWE-117: Improper Output Neutralization for Logs</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/93.html">CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')</a><br/>
    <a target="_blank" href="https://logback.qos.ch/manual/layouts.html#replace">CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')</a><br/>
    <a target="_blank" href="https://github.com/javabeanz/owasp-security-logging">OWASP Security Logging</a><br/>
</p>


        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="EXTERNAL_CONFIG_CONTROL"></a>
        <h2 class="page-header">
            潜在的な構成の外部制御
            <a href="#EXTERNAL_CONFIG_CONTROL" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>EXTERNAL_CONFIG_CONTROL</tt></small></em></p>

        
            
<p>
システム設定の外部制御を許可するとサービスが中断されたり，アプリケーションが予期せぬ悪意のある方法で動作させられたりする可能性があります。
攻撃者は，存在しないカタログ名を指定したり，データベースの権限のない部分に接続することによってエラーを引き起こすことができます。
</p>
<br/>
<p>
<b>リスクのあるコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>conn.setCatalog(request.getParameter("catalog"));</code></pre>
</p>
<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/15.html">CWE-15: External Control of System or Configuration Setting</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="BAD_HEXA_CONVERSION"></a>
        <h2 class="page-header">
            不正な16進数の連結
            <a href="#BAD_HEXA_CONVERSION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>BAD_HEXA_CONVERSION</tt></small></em></p>

        
            
<p>ハッシュ署名を含むバイト配列を人間が読める文字列に変換するとき，配列がバイト単位で読み取られると変換ミスが発生する可能性があります。
次のサンプルは，計算されたハッシュ値の各バイトから先行ゼロをトリムする <code>Integer.toHexString()</code> の使用方法を示しています。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>MessageDigest md = MessageDigest.getInstance("SHA-256");
byte[] resultBytes = md.digest(password.getBytes("UTF-8"));

StringBuilder stringBuilder = new StringBuilder();
for(byte b :resultBytes) {
    stringBuilder.append( Integer.toHexString( b & 0xFF ) );
}

return stringBuilder.toString();</code></pre>
</p>
<p>
この間違いは，より多くの衝突を招くので，計算されたハッシュ値を脆弱にします。
たとえば，上記の関数によってハッシュ値 "0x0679" と "0x6709" は，"679" として出力されます。
</p>

<p>
このような状況では，<code>Integer.toHexString()</code> メソッドを次のように <code>String.format()</code> に置き換えるべきです:
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>stringBuilder.append( String.format( "%02X", b ) );</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/704.html">CWE-704: Incorrect Type Conversion or Cast</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="HAZELCAST_SYMMETRIC_ENCRYPTION"></a>
        <h2 class="page-header">
            Hazelcast 対称暗号
            <a href="#HAZELCAST_SYMMETRIC_ENCRYPTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>HAZELCAST_SYMMETRIC_ENCRYPTION</tt></small></em></p>

        
            
<p>Hazelcast のネットワーク通信は，対称暗号 (おそらく DES または blowfish) を使用するように構成されています。</p>
<p>これらの暗号だけでは完全性や安全な認証が提供されません。非対称暗号を使用することが望ましいです。</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246945/Insufficient%20Transport%20Layer%20Protection">WASC-04: Insufficient Transport Layer Protection</a><br/>
<a target="_blank" href="https://docs.hazelcast.org/docs/3.5/manual/html/encryption.html">Hazelcast Documentation: Encryption</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/326.html">CWE-326: Inadequate Encryption Strength</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="NULL_CIPHER"></a>
        <h2 class="page-header">
            NullCipher は安全でない
            <a href="#NULL_CIPHER" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>NULL_CIPHER</tt></small></em></p>

        
            
<p>
NullCipher は，本番アプリケーションで意図的に使用されることはほとんどありません。
Cipher インタフェースは，与えられた平文と同一の暗号文を返すように実装されています。
テストなどのいくつかのコンテキストでは NullCipher が適切なときがあります。
</p>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cipher doNothingCihper = new NullCipher();
[...]
//The ciphertext produced will be identical to the plaintext.
byte[] cipherText = c.doFinal(plainText);</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
    NullCipher を使用しないでください。誤って使用すると重大な機密性リスクが生じる可能性があります。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/327.html">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="UNENCRYPTED_SOCKET"></a>
        <h2 class="page-header">
            暗号化されていないソケット
            <a href="#UNENCRYPTED_SOCKET" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>UNENCRYPTED_SOCKET</tt></small></em></p>

        
            
<p>
使用される通信チャネルは暗号化されていません。攻撃者がネットワークトラフィックを傍受して，トラフィックが読み取られる可能性があります。
</p>
<p>
<b>脆弱なコード:</b><br/>
プレーンソケット (平文通信):
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Socket soc = new Socket("www.google.com",80);</code></pre>
</p>
<p>
<b>解決策:</b><br/>
SSL ソケット (安全な通信):
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Socket soc = SSLSocketFactory.getDefault().createSocket("www.google.com", 443);</code></pre>
</p>
<p>SSL ソケットを使用する以外に，<code>SSLSocketFactory</code> を使用して，中間者攻撃の対象にならないように，すべての適切な証明書検証チェックを実行する必要があります。
チェックを正しく行う方法の詳細については，OWASP Transport Layer Protection Cheat Sheet をお読みください。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2010-A9">OWASP: Top 10 2010-A9-Insufficient Transport Layer Protection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure">OWASP: Top 10 2013-A6-Sensitive Data Exposure</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet">OWASP: Transport Layer Protection Cheat Sheet</a><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246945/Insufficient%20Transport%20Layer%20Protection">WASC-04: Insufficient Transport Layer Protection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/319.html">CWE-319: Cleartext Transmission of Sensitive Information</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="UNENCRYPTED_SERVER_SOCKET"></a>
        <h2 class="page-header">
            暗号化されていないサーバーソケット
            <a href="#UNENCRYPTED_SERVER_SOCKET" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>UNENCRYPTED_SERVER_SOCKET</tt></small></em></p>

        
            
<p>
使用される通信チャネルは暗号化されていません。攻撃者がネットワークトラフィックを傍受して，トラフィックが読み取られる可能性があります。
</p>
<p>
<b>脆弱なコード:</b><br/>
プレーンサーバーソケット (平文通信):
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>ServerSocket soc = new ServerSocket(1234);</code></pre>
</p>
<p>
<b>解決策:</b><br/>
SSL サーバーソケット (安全な通信):
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>ServerSocket soc = SSLServerSocketFactory.getDefault().createServerSocket(1234);</code></pre>
</p>
<p>SSL サーバーソケットを使用する以外に，<code>SSLServerSocketFactory</code> を使用することで，中間者攻撃の対象にならないように，すべての適切な証明書検証チェックを実行する必要があります。
チェックを正しく行う方法の詳細については，OWASP Transport Layer Protection Cheat Sheet をお読みください。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2010-A9">OWASP: Top 10 2010-A9-Insufficient Transport Layer Protection</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure">OWASP: Top 10 2013-A6-Sensitive Data Exposure</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet">OWASP: Transport Layer Protection Cheat Sheet</a><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246945/Insufficient%20Transport%20Layer%20Protection">WASC-04: Insufficient Transport Layer Protection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/319.html">CWE-319: Cleartext Transmission of Sensitive Information</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="DES_USAGE"></a>
        <h2 class="page-header">
            DES は安全でない
            <a href="#DES_USAGE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>DES_USAGE</tt></small></em></p>

        
            
<p>
DES は，今のアプリケーションでは強固な暗号とは見なされていません。現在，NIST は DES の代わりに AES ブロック暗号の使用を推奨しています。
</p>
<p>
    <b>弱いコードの例:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cipher c = Cipher.getInstance("DES/ECB/PKCS5Padding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</code></pre>
</p>
<p>
    <b>解決例:</b>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard">NIST Withdraws Outdated Data Encryption Standard</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/326.html">CWE-326: Inadequate Encryption Strength</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="TDES_USAGE"></a>
        <h2 class="page-header">
            DESede は安全でない
            <a href="#TDES_USAGE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>TDES_USAGE</tt></small></em></p>

        
            
<p>
トリプル DES (3DES または DESede としても知られている) は，今のアプリケーションでは強固な暗号とは見なされていません。
現在，NIST は 3DES の代わりに AES ブロック暗号の使用を推奨しています。
</p>
<p>
    <b>弱いコードの例:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</code></pre>
</p>
<p>
    <b>解決策の例:</b>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard">NIST Withdraws Outdated Data Encryption Standard</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/326.html">CWE-326: Inadequate Encryption Strength</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="RSA_NO_PADDING"></a>
        <h2 class="page-header">
            パディングなしの RSA 暗号は安全でない
            <a href="#RSA_NO_PADDING" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>RSA_NO_PADDING</tt></small></em></p>

        
            
<p>
ソフトウェアは RSA アルゴリズムを使用していますが，最適非対称暗号化パディング (OAEP:Optimal Asymmetric Encryption Padding) を組み込んでいないので，暗号を弱めるかもしれません。
</p>
<p>
<b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cipher.getInstance("RSA/NONE/NoPadding")</code></pre>
</p>
<p>
<b>解決策:</b><br/>
コードは次のように置き換えるべきです:<br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cipher.getInstance("RSA/ECB/OAEPWithMD5AndMGF1Padding")</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/780.html">CWE-780: Use of RSA Algorithm without OAEP</a><br/>
<a target="_blank" href="https://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/">Root Labs: Why RSA encryption padding is critical</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="HARD_CODE_PASSWORD"></a>
        <h2 class="page-header">
            ハードコードされたパスワード
            <a href="#HARD_CODE_PASSWORD" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>HARD_CODE_PASSWORD</tt></small></em></p>

        
            
<p>
パスワードをソースコード内に保持すべきではありません。ソースコードは，エンタープライズ環境で広く共有することができ，オープンソースでは確実に共有されます。
安全に管理するためには，パスワードと秘密鍵を別々の設定ファイルやキーストアに格納すべきです。
(ハードコードされた鍵は <i>ハードコードされた鍵</i> パターンで別々に報告されます)
</p>
<p>
<p><b>脆弱なコード:</b><br/>

<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>private String SECRET_PASSWORD = "letMeIn!";

Properties props = new Properties();
props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/259.html">CWE-259: Use of Hard-coded Password</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="HARD_CODE_KEY"></a>
        <h2 class="page-header">
            ハードコードされた鍵
            <a href="#HARD_CODE_KEY" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>HARD_CODE_KEY</tt></small></em></p>

        
            
<p>
暗号鍵をソースコード内に保持すべきではありません。ソースコードは，エンタープライズ環境で広く共有することができ，オープンソースでは確実に共有されます。
安全に管理するためには，パスワードと秘密鍵を別々の設定ファイルやキーストアに格納すべきです。
(ハードコードされたパスワードは <i>ハードコードされたパスワード</i> パターンで別々に報告されます)
</p>
<p>
<p><b>脆弱なコード:</b><br/>

<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>byte[] key = {1, 2, 3, 4, 5, 6, 7, 8};
SecretKeySpec spec = new SecretKeySpec(key, "AES");
Cipher aes = Cipher.getInstance("AES");
aes.init(Cipher.ENCRYPT_MODE, spec);
return aesCipher.doFinal(secretData);</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/321.html">CWE-321: Use of Hard-coded Cryptographic Key</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="UNSAFE_HASH_EQUALS"></a>
        <h2 class="page-header">
            安全でないハッシュの比較
            <a href="#UNSAFE_HASH_EQUALS" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>UNSAFE_HASH_EQUALS</tt></small></em></p>

        
            
<p>
攻撃者は，比較タイミングの暴露による秘密ハッシュ値を検出できます。
関数 <code>Arrays.equals()</code> または <code>String.equals()</code> が呼び出されると一致するバイト数が少ないと早く終了します。
</p>
<p>
<p><b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>String actualHash = ...

if(userInput.equals(actualHash)) {
    ...
}</code></pre>
</p>
<p><b>解決策:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>String actualHash = ...

if(MessageDigest.isEqual(userInput.getBytes(),actualHash.getBytes())) {
    ...
}</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/203.html">CWE-203: Information Exposure Through DiscrepancyKey</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="STRUTS_FORM_VALIDATION"></a>
        <h2 class="page-header">
            入力検証がない Struts フォーム
            <a href="#STRUTS_FORM_VALIDATION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>STRUTS_FORM_VALIDATION</tt></small></em></p>

        
            
<p>
フォーム入力には，最低限の入力検証が必要です。予防的な検証は，さまざまなリスクに対して多重防御を提供します。
</p>
<p>
検証は，<code>validate</code> メソッドを実装することで導入できます。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public class RegistrationForm extends ValidatorForm {

    private String name;
    private String email;

    [...]

    public ActionErrors validate(ActionMapping mapping, HttpServletRequest request) {
        // HttpRequest を介して渡された名前と電子メールパラメーターの検証コードはここに
    }
}
</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/106.html">CWE-106: Struts: Plug-in Framework not in Use</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="XSS_REQUEST_WRAPPER"></a>
        <h2 class="page-header">
            XSSRequestWrapper は弱い XSS 保護
            <a href="#XSS_REQUEST_WRAPPER" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>XSS_REQUEST_WRAPPER</tt></small></em></p>

        
            
<p>
<code>XSSRequestWrapper</code> と呼ばれる <code>HttpServletRequestWrapper</code> の実装は，さまざまなブログサイトで公開されていました。
<sup><a target="_blank" href="https://java.dzone.com/articles/stronger-anti-cross-site">[1]</a></sup>
<sup><a target="_blank" href="https://www.javacodegeeks.com/2012/07/anti-cross-site-scripting-xss-filter.html">[2]</a></sup>
</p>
<p>
フィルタリングはいくつかの理由から弱いです:
<ul>
<li>カバーしているのはパラメーターだけで，ヘッダーやサイドチャネル入力はカバーしていない</li>
<li>置換機能のチェーンは簡単に迂回できる (下の例を参照)</li>
<li>非常に特殊な悪いパターンのブラックリスト (良い/有効な入力のホワイトリストではなく)</li>
</ul>
</p>
<p>
<b>迂回の例:</b><br/>
</p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;scrivbscript:pt&gt;alert(1)&lt;/scrivbscript:pt&gt;</code></pre>
<p>
前述の入力は <b><code>"&lt;script&gt;alert(1)&lt;/script&gt;"</code></b> に変換されます。
<code>"vbscript:"</code> の除去は，<code>"&lt;script&gt;.*&lt;/script&gt;"</code> の置換が行われた後です。
</p>
<p>
強力な保護のために，OWASP XSS Prevention Cheat Sheet で定義されている XSS 保護ルールに従って，<b><u>view</u></b> (template, jsp, ...) で文字を自動的にエンコードする解決策を選択してください。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8: Cross Site Scripting</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP: XSS Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="BLOWFISH_KEY_SIZE"></a>
        <h2 class="page-header">
            短い鍵での Blowfish の使用
            <a href="#BLOWFISH_KEY_SIZE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>BLOWFISH_KEY_SIZE</tt></small></em></p>

        
            
<p>
Blowfish 暗号は，32ビットから448ビットの鍵長をサポートしています。鍵長が短いと，暗号文は総当たり攻撃 (Brute-force attack) に対して脆弱になります。
Blowfish の使用が必要なときは，鍵を生成するときに少なくとも128ビットのエントロピーを使用すべきです。
</p>
<p>
アルゴリズムを変更できるときは，代わりに AES ブロック暗号を使用すべきです。
</p>

<p><b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
keyGen.init(64);</code></pre>
</p>

<p><b>解決策:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
keyGen.init(128);</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://en.wikipedia.org/wiki/Blowfish_(cipher)">Blowfish (cipher)</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/326.html">CWE-326: Inadequate Encryption Strength</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="RSA_KEY_SIZE"></a>
        <h2 class="page-header">
            短い鍵長での RSA の使用
            <a href="#RSA_KEY_SIZE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>RSA_KEY_SIZE</tt></small></em></p>

        
            
<p>
NISTは，RSA アルゴリズムに <u>2048ビット以上</u> の鍵を使用することを推奨しています。
</p>
<blockquote>
    "Digital Signature Verification | RSA: <code>1024 &le; len(n) &lt; 2048</code> | Legacy-use"<br/>
    "Digital Signature Verification | RSA: <code>len(n) &ge; 2048</code> | Acceptable"<br/>
    - <a target="_blank" href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf">NIST: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.7</a>
</blockquote>

<p><b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(512);
</code></pre>
</p>

<p><b>解決策:</b><br/>
KeyPairGenerator の作成は，次のように少なくとも2048ビットの鍵長にすべきです。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(2048);
</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://csrc.nist.gov/projects/key-management">NIST: Latest publication on key management</a><br/>
<a target="_blank" href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf">NIST: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.7</a><br/>
<a target="_blank" href="https://en.wikipedia.org/wiki/Key_size#Asymmetric%5Falgorithm%5Fkey%5Flengths">Wikipedia: Asymmetric algorithm key lengths</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/326.html">CWE-326: Inadequate Encryption Strength</a><br/>
<a target="_blank" href="https://www.keylength.com/en/compare/">Keylength.com (BlueKrypt): Aggregate key length recommendations.</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="UNVALIDATED_REDIRECT"></a>
        <h2 class="page-header">
            未検証のリダイレクト
            <a href="#UNVALIDATED_REDIRECT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>UNVALIDATED_REDIRECT</tt></small></em></p>

        
            
<p>
検証されていないユーザー指定のパラメーターで指定された宛先 URL にユーザーをリダイレクトすると未検証のリダイレクトが発生します。
このような脆弱性を利用して，フィッシング攻撃を容易にすることができます。
</p>
<p>
    <b>シナリオ</b><br/>
    1. ユーザーは，悪意のある URL にアクセスするようにだまされる: <code>http://website.com/login?redirect=http://evil.vvebsite.com/fake/login</code><br/>
    2. ユーザーは，信頼できるサイトのように見える偽のログインページにリダイレクトされる (<code>http://evil.vvebsite.com/fake/login</code>)<br/>
    3. ユーザーは自分の認証情報を入力する<br/>
    4. 悪意のあるサイトはユーザーの認証情報を盗み，元の Web サイトにリダイレクトする<br/>
    <br/>
    ほとんどのユーザーがリダイレクト後に URL をダブルチェックしないため，この攻撃は最もらしく思われます。また，認証ページへのリダイレクトもよくあります。
</p>
<p>
    <b>脆弱なコード:</b></br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    [...]
    resp.sendRedirect(req.getParameter("redirectUrl"));
    [...]
}</code></pre>
</p>
<p>
    <b>解決策/対策:</b><br/>
    <ul>
        <li>ユーザーからリダイレクト先を受け入れない</li>
        <li>宛先キーを受け入れ，それを使用して対象 (合法) の宛先をルックアップする</li>
        <li>相対パスだけを受け入れる</li>
        <li>URL のホワイトリスト (可能な場合)</li>
        <li>URL の先頭がホワイトリストの一部であることを検証する</li>
    </ul>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246981/URL%20Redirector%20Abuse">WASC-38: URL Redirector Abuse</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A10-Unvalidated_Redirects_and_Forwards">OWASP: Top 10 2013-A10: Unvalidated Redirects and Forwards</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet">OWASP: Unvalidated Redirects and Forwards Cheat Sheet</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/601.html">CWE-601: URL Redirection to Untrusted Site ('Open Redirect')</a>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="PLAY_UNVALIDATED_REDIRECT"></a>
        <h2 class="page-header">
            未検証のリダイレクト (Play Framework)
            <a href="#PLAY_UNVALIDATED_REDIRECT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>PLAY_UNVALIDATED_REDIRECT</tt></small></em></p>

        
            
<p>
検証されていないユーザー指定のパラメーターで指定された宛先 URL にユーザーをリダイレクトすると未検証のリダイレクトが発生します。
このような脆弱性を利用して，フィッシング攻撃を容易にすることができます。
</p>
<p>
    <b>シナリオ</b><br/>
    1. ユーザーは，悪意のある URL にアクセスするようにだまされる: <code>http://website.com/login?redirect=http://evil.vvebsite.com/fake/login</code><br/>
    2. ユーザーは，信頼できるサイトのように見える偽のログインページにリダイレクトされる (<code>http://evil.vvebsite.com/fake/login</code>)<br/>
    3. ユーザーは自分の認証情報を入力する<br/>
    4. 悪意のあるサイトはユーザーの認証情報を盗み，元の Web サイトにリダイレクトする<br/>
    <br/>
    ほとんどのユーザーがリダイレクト後に URL をダブルチェックしないため，この攻撃は最もらしく思われます。また，認証ページへのリダイレクトもよくあります。
</p>
<p>
    <b>脆弱なコード:</b></br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>def login(redirectUrl:String) = Action {
    [...]
    Redirect(url)
}</code></pre>
</p>
<p>
    <b>解決策/対策:</b><br/>
    <ul>
        <li>ユーザーからリダイレクト先を受け入れない</li>
        <li>宛先キーを受け入れ，それを使用して対象 (合法) の宛先をルックアップする</li>
        <li>相対パスだけを受け入れる</li>
        <li>URL のホワイトリスト (可能な場合)</li>
        <li>URL の先頭がホワイトリストの一部であることを検証する</li>
    </ul>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246981/URL%20Redirector%20Abuse">WASC-38: URL Redirector Abuse</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A10-Unvalidated_Redirects_and_Forwards">OWASP: Top 10 2013-A10: Unvalidated Redirects and Forwards</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet">OWASP: Unvalidated Redirects and Forwards Cheat Sheet</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/601.html">CWE-601: URL Redirection to Untrusted Site ('Open Redirect')</a>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SPRING_UNVALIDATED_REDIRECT"></a>
        <h2 class="page-header">
            未検証のリダイレクト (Spring アプリケーション)
            <a href="#SPRING_UNVALIDATED_REDIRECT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SPRING_UNVALIDATED_REDIRECT</tt></small></em></p>

        
            
<p>
検証されていないユーザー指定のパラメーターで指定された宛先 URL にユーザーをリダイレクトすると未検証のリダイレクトが発生します。
このような脆弱性を利用して，フィッシング攻撃を容易にすることができます。
</p>
<p>
    <b>シナリオ</b><br/>
    1. ユーザーは，悪意のある URL にアクセスするようにだまされる: <code>http://website.com/login?redirect=http://evil.vvebsite.com/fake/login</code><br/>
    2. ユーザーは，信頼できるサイトのように見える偽のログインページにリダイレクトされる (<code>http://evil.vvebsite.com/fake/login</code>)<br/>
    3. ユーザーは自分の認証情報を入力する<br/>
    4. 悪意のあるサイトはユーザーの認証情報を盗み，元の Web サイトにリダイレクトする<br/>
    <br/>
    ほとんどのユーザーがリダイレクト後に URL をダブルチェックしないため，この攻撃は最もらしく思われます。また，認証ページへのリダイレクトもよくあります。
</p>
<p>
    <b>脆弱なコード:</b></br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>@RequestMapping("/redirect")
public String redirect(@RequestParam("url") String url) {
    [...]
    return "redirect:" + url;
}</code></pre>
</p>
<p>
    <b>解決策/対策:</b><br/>
    <ul>
        <li>ユーザーからリダイレクト先を受け入れない</li>
        <li>宛先キーを受け入れ，それを使用して対象 (合法) の宛先をルックアップする</li>
        <li>相対パスだけを受け入れる</li>
        <li>URL のホワイトリスト (可能な場合)</li>
        <li>URL の先頭がホワイトリストの一部であることを検証する</li>
    </ul>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246981/URL%20Redirector%20Abuse">WASC-38: URL Redirector Abuse</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A10-Unvalidated_Redirects_and_Forwards">OWASP: Top 10 2013-A10: Unvalidated Redirects and Forwards</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet">OWASP: Unvalidated Redirects and Forwards Cheat Sheet</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/601.html">CWE-601: URL Redirection to Untrusted Site ('Open Redirect')</a>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="ENTITY_LEAK"></a>
        <h2 class="page-header">
            予期しないプロパティ漏洩
            <a href="#ENTITY_LEAK" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>ENTITY_LEAK</tt></small></em></p>

        
            
<p>
永続オブジェクトは，APIによって返されるべきではありません。
UIを介してビジネスロジックが漏洩したり，データベース内の永続オブジェクトが不正に改ざんされたりする可能性があります。
</p>
<p>
    <b>脆弱なコード:</b></br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>@javax.persistence.Entity
class UserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;

    private String password;
}

[...]
@Controller
class UserController {

    @GetMapping("/user/{id}")
    public UserEntity getUser(@PathVariable("id") String id) {

        return userService.findById(id).get(); //Return the user entity with ALL fields.
    }

}
</code></pre>
</p>
<p>
    <b>解決策/対策:</b><br/>
    <ul>
        <li>データ転送オブジェクトは，API への入力/応答として必要なパラメーターだけを含めて，代わりに使用する必要がある</li>
        <li>機密パラメーターは，UI に転送する前に適切に削除する必要がある</li>
        <li>データは，適切なサニタイズチェックの後にだけデータベースに保存されるべきである</li>
    </ul>
</p>
<p>
    <b>Spring MVC 解決策:</b><br/>
    特に Spring では，次の解決策を適用して特定のフィールドを許可または禁止にできます。

        <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>@Controller
class UserController {

   @InitBinder
   public void initBinder(WebDataBinder binder, WebRequest request)
   {
      binder.setAllowedFields(["username","firstname","lastname"]);
   }

}
    </code></pre>
</p>

<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure">OWASP Top 10-2017 A3: Sensitive Data Exposure</a><br/>
<a target="_blank" href="https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html#spring-mvc">OWASP Cheat Sheet: Mass Assignment</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/212.html">CWE-212: Improper Cross-boundary Removal of Sensitive Data</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/213.html">CWE-213: Intentional Information Exposure</a><br/>


</p>

            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="ENTITY_MASS_ASSIGNMENT"></a>
        <h2 class="page-header">
            一括割り当て
            <a href="#ENTITY_MASS_ASSIGNMENT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>ENTITY_MASS_ASSIGNMENT</tt></small></em></p>

        
            
<p>
永続オブジェクトは，APIによって返されるべきではありません。
UIを介してビジネスロジックが漏洩したり，データベース内の永続オブジェクトが不正に改ざんされたりする可能性があります。
</p>
<p>
    <b>脆弱なコード:</b></br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>@javax.persistence.Entity
class UserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;

    private String password;

    private Long role;
}

[...]
@Controller
class UserController {

    @PutMapping("/user/")
    @ResponseStatus(value = HttpStatus.OK)
    public void update(UserEntity user) {

        userService.save(user); //ALL fields from the user can be altered
    }

}
</code></pre>
</p>
<p>
    <b>一般的なガイドライン:</b><br/>
    <ul>
        <li>データ転送オブジェクトは，API への入力/応答として必要なパラメーターだけを含めて，代わりに使用する必要がある</li>
        <li>機密パラメーターは，UI に転送する前に適切に削除する必要がある</li>
        <li>データは，適切なサニタイズチェックの後にだけデータベースに保存されるべきである</li>
    </ul>
</p>
<p>
    <b>Spring MVC 解決策:</b><br/>
    特に Spring では，次の解決策を適用して特定のフィールドを許可または禁止にできます。<br/>
<br/>
With whitelist:<br/>
        <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>@Controller
class UserController {

   @InitBinder
   public void initBinder(WebDataBinder binder, WebRequest request)
   {
      binder.setAllowedFields(["username","password"]);
   }

}
    </code></pre>
<br/>
With a blacklist:<br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>@Controller
class UserController {

   @InitBinder
   public void initBinder(WebDataBinder binder, WebRequest request)
   {
      binder.setDisallowedFields(["role"]);
   }

}
    </code></pre>
</p>

<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html#spring-mvc">OWASP Cheat Sheet: Mass Assignment</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/915.html">CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="JSP_INCLUDE"></a>
        <h2 class="page-header">
            動的 JSP インクルード
            <a href="#JSP_INCLUDE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>JSP_INCLUDE</tt></small></em></p>

        
            
<p>JSP ファイルをインクルードすることで，動的な値を入力できます。攻撃者がインクルードする JSP ページを制御する可能性があります。
その場合，攻撃者は自分が制御しているディスクにファイルを含めるように試みます。任意のファイルを含めることにより，攻撃者は任意のコードを実行できます。
</p>
<p>
    <b>脆弱なコード:</b>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;jsp:include page="${param.secret_param}" /&gt;</code></pre>
</p>
<p>
    <b>解決策:</b>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;c:if test="${param.secret_param == 'page1'}"&gt;
    &lt;jsp:include page="page1.jsp" /&gt;
&lt;/c:if&gt;</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://resources.infosecinstitute.com/file-inclusion-attacks/">InfosecInstitute: File Inclusion Attacks</a><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246955/Remote%20File%20Inclusion">WASC-05: Remote File Inclusion</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="JSP_SPRING_EVAL"></a>
        <h2 class="page-header">
            Spring 式の動的変数
            <a href="#JSP_SPRING_EVAL" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>JSP_SPRING_EVAL</tt></small></em></p>

        
            
<p>Spring 式は，動的な値で構築されています。フィルタされていない値がこの危険なコード評価になることを避けるために値の発生源を検証すべきです。
</p>
<p>
    <b>脆弱なコード:</b>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;%@ taglib prefix="spring" uri="http://www.springframework.org/tags" %&gt;

&lt;spring:eval expression="${param.lang}" var="lang" /&gt;</code></pre>
    <br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;%@ taglib prefix="spring" uri="http://www.springframework.org/tags" %&gt;

&lt;spring:eval expression="'${param.lang}'=='fr'" var="languageIsFrench" /&gt;</code></pre>
</p>
<p>
    <b>解決策:</b>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;c:set var="lang" value="${param.lang}"/&gt;</code></pre>
    <br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;c:set var="languageIsFrench" value="${param.lang == 'fr'}"/&gt;</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/94.html">CWE-94: Improper Control of Generation of Code ('Code Injection')</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/95.html">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="JSP_JSTL_OUT"></a>
        <h2 class="page-header">
            特別な XML 文字のエスケープが無効
            <a href="#JSP_JSTL_OUT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>JSP_JSTL_OUT</tt></small></em></p>

        
            
<p>
潜在的な XSS を発見しました。クライアントのブラウザーで望まれていない JavaScript を実行するために使用される可能性があります。(参考文献を参照)
</p>
<p>
    <b>脆弱なコード:</b>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;

&lt;c:out value="${param.test_param}" escapeXml="false"/&gt;</code></pre>
</p>
<p>
    <b>解決策:</b>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;

&lt;c:out value="${param.test_param}"/&gt;</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8: Cross Site Scripting</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP: XSS Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a><br/>
<a target="_blank" href="https://docs.oracle.com/javaee/5/jstl/1.1/docs/tlddocs/c/out.html">JSTL Javadoc: Out tag</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="XSS_JSP_PRINT"></a>
        <h2 class="page-header">
            JSP 内の潜在的な XSS
            <a href="#XSS_JSP_PRINT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>XSS_JSP_PRINT</tt></small></em></p>

        
            
<p>
潜在的な XSS を発見しました。クライアントのブラウザーで望まれていない JavaScript を実行するために使用される可能性があります。(参考文献を参照)
</p>
<p>
    <b>脆弱なコード:</b>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'><%
String taintedInput = (String) request.getAttribute("input");
%>
[...]
&lt;%= taintedInput %&gt;</code></pre>
</p>
<p>
    <b>解決策:</b>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;%
String taintedInput = (String) request.getAttribute("input");
%&gt;
[...]
&lt;%= Encode.forHtml(taintedInput) %&gt;
    </code></pre>
</p>
<p>
XSS に対する最善の防御は，上記の例のような特定の状況で使える出力エンコーディングです。
考慮すべきコンテキストは4つあります: HTML，JavaScript，CSS (スタイル)，URL です。
OWASP XSS Prevention Cheat Sheet で定義されている XSS 保護ルールに従ってください。これらの防御について詳細に説明しています。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8: Cross Site Scripting</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP: XSS Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a><br/>
<a target="_blank" href="https://code.google.com/p/owasp-java-encoder/">OWASP Java Encoder</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="XSS_SERVLET"></a>
        <h2 class="page-header">
            サーブレット内の潜在的な XSS
            <a href="#XSS_SERVLET" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>XSS_SERVLET</tt></small></em></p>

        
            
<p>
潜在的な XSS を発見しました。クライアントのブラウザーで望まれていない JavaScript を実行するために使用される可能性があります。(参考文献を参照)
</p>
<p>
    <b>脆弱なコード:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String input1 = req.getParameter("input1");
    [...]
    resp.getWriter().write(input1);
}</code></pre>
</p>
<p>
    <b>解決策:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String input1 = req.getParameter("input1");
    [...]
    resp.getWriter().write(Encode.forHtml(input1));
}</code></pre>
</p>
<p>
XSSに対する最善の防御は，上記の例のような特定の状況で使える出力エンコーディングです。
考慮すべきコンテキストは4つあります: HTML，JavaScript，CSS (スタイル)，URL です。
OWASP XSS Prevention Cheat Sheet で定義されている XSS 保護ルールに従ってください。これらの防御について詳細に説明しています。
</p>
<p>サーブレット XSS ルールは類似の問題を探しますが，既存の SpotBugs のルール「XSS:型クロスサイトスクリプティング脆弱性があるサーブレット」と
「XSS:反射型クロスサイトスクリプティング脆弱性がエラーページにあるサーブレット」とは異なる方法で探します。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8: Cross Site Scripting</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP: XSS Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a><br/>
<a target="_blank" href="https://code.google.com/p/owasp-java-encoder/">OWASP Java Encoder</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="XML_DECODER"></a>
        <h2 class="page-header">
            XMLDecoder の使用
            <a href="#XML_DECODER" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>XML_DECODER</tt></small></em></p>

        
            
<p>
信頼できないデータを解析するために <code>XMLDecoder</code> を使用すべきではありません。ユーザー入力をデシリアライズすると任意のコードが実行される可能性があります。
これは，<code>XMLDecoder</code> が任意のメソッド呼び出しをサポートしているので可能です。この機能はセッターメソッドを呼び出すことを意図していますが，実際にはどんなメソッドも呼び出せます。
</p>
<p>
    <b>悪意のある XML の例</b>
</p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;java version="1.4.0" class="java.beans.XMLDecoder"&gt;
  &lt;object class="java.io.PrintWriter"&gt;
    &lt;string>/tmp/Hacked.txt&lt;/string&gt;
    &lt;void method="println"&gt;
      &lt;string>Hello World!&lt;/string&gt;
    &lt;/void&gt;
    &lt;void method="close"/&gt;
  &lt;/object&gt;
&lt;/java&gt;
</code></pre>
<p>
上記の XML コードはコンテンツ "Hello World!" を持つファイルが作成されます。
</p>
<p>
    <b>脆弱なコード:</b></br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>XMLDecoder d = new XMLDecoder(in);
try {
    Object result = d.readObject();
}
[...]</code></pre>
</p>
<p>
<b>解決策:</b></br/>
解決策は，信頼できないソースからのコンテンツの解析に <code>XMLDecoder</code> を使用しないようにすることです。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html">Dinis Cruz Blog: Using XMLDecoder to execute server-side Java Code on an Restlet application</a><br/>
<a target="_blank" href="https://securityblog.redhat.com/2014/01/23/java-deserialization-flaws-part-2-xml-deserialization/">RedHat blog : Java deserialization flaws: Part 2, XML deserialization</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="STATIC_IV"></a>
        <h2 class="page-header">
            静的な初期化ベクトル (Static IV)
            <a href="#STATIC_IV" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>STATIC_IV</tt></small></em></p>

        
            
<p>
暗号化するメッセージごとに初期化ベクトル (IV:Initialization vector) を再生成しなければなりません。
</p>
<p><b>脆弱なコード:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>private static byte[] IV = new byte[16] {(byte)0,(byte)1,(byte)2,[...]};

public void encrypt(String message) throws Exception {

    IvParameterSpec ivSpec = new IvParameterSpec(IV);
[...]
</code></pre>
<p><b>解決策:</b></p>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public void encrypt(String message) throws Exception {

    byte[] iv = new byte[16];
    new SecureRandom().nextBytes(iv);

    IvParameterSpec ivSpec = new IvParameterSpec(iv);
[...]
</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://en.wikipedia.org/wiki/Initialization_vector">Wikipedia: Initialization vector</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/329.html">CWE-329: Not Using a Random IV with CBC Mode</a><br/>
<a target="_blank" href="https://defuse.ca/cbcmodeiv.htm">Encryption - CBC Mode IV: Secret or Not?</a>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="ECB_MODE"></a>
        <h2 class="page-header">
            ECB モードは安全でない
            <a href="#ECB_MODE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>ECB_MODE</tt></small></em></p>

        
            
<p>守秘義務のない Electronic Code Book (ECB) モードの代わりに暗号化されたデータのより良い機密性を提供する認証暗号モードを使用すべきです。
特に，ECB モードは毎回同じ入力に対して同じ出力を生成します。たとえば，ユーザーがパスワードを送信するとき，暗号化された値は毎回同じです。
これにより，攻撃者はデータを傍受して再生することができます。</p>
<p>
修正するためには，Galois/Counter Mode (GCM) のようなものを代わりに使用すべきです。
</p>
<p>
<b>リスクのあるコード:</b>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cipher c = Cipher.getInstance("AES/ECB/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</code></pre>
</p>
<p>
    <b>解決策:</b>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://en.wikipedia.org/wiki/Authenticated_encryption">Wikipedia: Authenticated encryption</a><br/>
<a target="_blank" href="https://csrc.nist.gov/projects/block-cipher-techniques/bcm/modes-develoment#01">NIST: Authenticated Encryption Modes</a><br/>
<a target="_blank" href="https://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29">Wikipedia: Block cipher modes of operation</a><br/>
<a target="_blank" href="https://csrc.nist.gov/publications/detail/sp/800-38a/final">NIST: Recommendation for Block Cipher Modes of Operation</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="PADDING_ORACLE"></a>
        <h2 class="page-header">
            パディングオラクル攻撃の影響を受けやすい暗号
            <a href="#PADDING_ORACLE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>PADDING_ORACLE</tt></small></em></p>

        

<p>
この特定のモード (PKCS5Padding を使った CBC) は，パッディングオラクル攻撃の影響を受けやすいです。
システムが無効または有効なパディングによって平文の違いを暴露すると，攻撃者はメッセージを解読できるかもしれません。
有効なパディングと無効なパディングの違いは，通常，各条件に対して返されるエラーメッセージによって明らかにされます。
</p>
<p>
    <b>リスクのあるコード:</b>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</code></pre>
</p>
<p>
    <b>解決策:</b>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</code></pre>
</p>
<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf">Padding Oracles for the masses (by Matias Soler)</a><br/>
    <a target="_blank" href="https://en.wikipedia.org/wiki/Authenticated_encryption">Wikipedia: Authenticated encryption</a><br/>
    <a target="_blank" href="https://csrc.nist.gov/projects/block-cipher-techniques/bcm/modes-develoment#01">NIST: Authenticated Encryption Modes</a><br/>
    <a target="_blank" href="https://capec.mitre.org/data/definitions/463.html">CAPEC: Padding Oracle Crypto Attack</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/696.html">CWE-696: Incorrect Behavior Order</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="CIPHER_INTEGRITY"></a>
        <h2 class="page-header">
            整合性のない暗号
            <a href="#CIPHER_INTEGRITY" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>CIPHER_INTEGRITY</tt></small></em></p>

        

<p>
生成された暗号文は，攻撃者によって改ざんされやすいです。これは，データが改ざんされたことを検出する方法を暗号が提供しないことを意味します。
暗号文が攻撃者によって制御される可能性があると検出されることなく変更される可能性があります。
</p>
<p>
解決策は，データに署名するためのハッシュベースのメッセージ認証コード (HMAC:Hash-based Message Authentication Code) を含む暗号を使用することです。
HMAC 関数を既存の暗号と組み合わせると，エラーが発生しやすくなります <sup><a target="_blank" href="https://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/">[1]</a></sup>。
具体的には，常に HMAC を最初に検証できることが推奨されます。データが変更されていないときに限り，データに対して暗号化関数を実行します。
</p>
<p>次のモードは，HMAC を提供しないため脆弱です。<br/>
    - CBC<br/>
    - OFB<br/>
    - CTR<br/>
    - ECB<br/><br/>
    次のスニペットコードは，脆弱なコードの例です。<br/><br/>
    <b>リスクのあるコード:</b><br/>
    <i>CBC モードで AES</i><br/>

    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</code></pre>
    <br/>
    <i>ECB モードのトリプル DES</i><br/>

<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</code></pre>
</p>
<p>
    <b>解決策:</b>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</code></pre>
</p>
<p>
上記の解決例では，GCM モードは結果の暗号化されたデータに HMAC を導入し，結果の完全性を提供します。
</p>
<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="https://en.wikipedia.org/wiki/Authenticated_encryption">Wikipedia: Authenticated encryption</a><br/>
    <a target="_blank" href="https://csrc.nist.gov/projects/block-cipher-techniques/bcm/modes-develoment#01">NIST: Authenticated Encryption Modes</a><br/>
    <a target="_blank" href="https://moxie.org/blog/the-cryptographic-doom-principle/">Moxie Marlinspike's blog: The Cryptographic Doom Principle</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/353.html">CWE-353: Missing Support for Integrity Check</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="ESAPI_ENCRYPTOR"></a>
        <h2 class="page-header">
            ESAPI Encryptor の使用
            <a href="#ESAPI_ENCRYPTOR" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>ESAPI_ENCRYPTOR</tt></small></em></p>

        

<p>
ESAPI には，暗号化コンポーネント内にちょっとした脆弱性の前歴があります。
ここでは，認証付き暗号 (Authenticated Encryption) が期待どおりに機能しているかどうかを確認する簡単な検証リストを示します。
</p>
<p><b>1. ライブラリーのバージョン</b></p>
<p>
この問題は，ESAPI のバージョン 2.1.0 で修正されています。バージョン 2.0.1 以前は，MAC バイパスに対して脆弱です (CVE-2013-5679)。<br/>
</p>
<p>
    Maven ユーザーならプラグイン <a target="_blank" href="https://mojo.codehaus.org/versions-maven-plugin/">versions</a> を次のコマンドを使用して呼び出せます。
    ESAPI の有効なバージョンは，その出力から入手できます。<br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>$ mvn versions:display-dependency-updates</code></pre>
    <br/>出力:<br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>[...]
[INFO] The following dependencies in Dependencies have newer versions:
[INFO]   org.slf4j:slf4j-api ................................... 1.6.4 -> 1.7.7
[INFO]   org.owasp.esapi:esapi ................................. 2.0.1 -> 2.1.0
[...]
    </code></pre>
</p>
<p>
    または，直接設定を見ることによって.<br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;dependency&gt;
    &lt;groupId&gt;org.owasp.esapi&lt;/groupId&gt;
    &lt;artifactId&gt;esapi&lt;/artifactId&gt;
    &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</p>
<p>
Ant ユーザーなら使用する jar は <a target="_blank" href="https://repo1.maven.org/maven2/org/owasp/esapi/esapi/2.1.0/esapi-2.1.0.jar">esapi-2.1.0.jar</a> でなければなりません。
</p>
<p><b>2. 設定:</b></p>
    <p>
    ライブラリーバージョン2.1.0は，暗号文定義で変更さる鍵長に対して依然として脆弱です  (CVE-2013-5960)。いくつかの予防措置を講ずる必要があります。<br/>
    <br/>
    <div><b>これらの要素のいずれかが存在すると ESAPI の暗号化設定も脆弱になる可能性があります:</b><br/>
    <b>安全でない設定:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Encryptor.CipherText.useMAC=false

Encryptor.EncryptionAlgorithm=AES
Encryptor.CipherTransformation=AES/CBC/PKCS5Padding

Encryptor.cipher_modes.additional_allowed=CBC</code></pre>
    </div>
</p>
<p>
    <div>
    <b>Secure configuration:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>#必要
Encryptor.CipherText.useMAC=true

#信頼できる認証が必要
Encryptor.EncryptionAlgorithm=AES
Encryptor.CipherTransformation=AES/GCM/NoPadding

#パディングオラクルを避けるために CBC モードを削除すべき
Encryptor.cipher_modes.additional_allowed=</code></pre>
    </div>
</p>
<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="https://github.com/peval/owasp-esapi-java/blob/master/documentation/ESAPI-security-bulletin1.pdf">ESAPI Security bulletin 1 (CVE-2013-5679)</a><br/>
    <a target="_blank" href="https://nvd.nist.gov/vuln/detail/CVE-2013-5679">Vulnerability Summary for CVE-2013-5679</a><br/>
    <a target="_blank" href="https://www.synacktiv.com/ressources/synacktiv_owasp_esapi_hmac_bypass.pdf">Synactiv: Bypassing HMAC validation in OWASP ESAPI symmetric encryption</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/310.html">CWE-310: Cryptographic Issues</a><br/>
    <a target="_blank" href="https://lists.owasp.org/pipermail/esapi-dev/2015-March/002533">ESAPI-dev mailing list: Status of CVE-2013-5960</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="ANDROID_EXTERNAL_FILE_ACCESS"></a>
        <h2 class="page-header">
            外部ファイルアクセス (Android)
            <a href="#ANDROID_EXTERNAL_FILE_ACCESS" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>ANDROID_EXTERNAL_FILE_ACCESS</tt></small></em></p>

        
            
<p>
アプリケーションは外部ストレージ (SD カード) にデータを書き込みます。このアクションには複数のセキュリティの影響があります。
まず，SD カード上のファイルストアは，<a target="_blank" href="https://developer.android.com/reference/android/Manifest.permission.html#READ_EXTERNAL_STORAGE"><code>READ_EXTERNAL_STORAGE</code></a>
権限を持つアプリケーションからアクセスできるようになります。
また，永続化されたデータにユーザーに関する機密情報が含まれているときは，暗号化が必要になります。
</p>
<p>
    <b>リスクのあるコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>file file = new File(getExternalFilesDir(TARGET_TYPE), filename);
fos = new FileOutputStream(file);
fos.write(confidentialData.getBytes());
fos.flush();
</code></pre>
</p>
<p>
    <b>より良い代替手段:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>fos = openFileOutput(filename, Context.MODE_PRIVATE);
fos.write(string.getBytes());
</code></pre>
</p>
<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="https://developer.android.com/training/articles/security-tips.html#ExternalStorage">Android Official Doc: Security Tips</a><br/>
    <a target="_blank" href="https://www.securecoding.cert.org/confluence/display/java/DRD00-J.+Do+not+store+sensitive+information+on+external+storage+%28SD+card%29+unless+encrypted+first">CERT: DRD00-J: Do not store sensitive information on external storage [...]</a><br/>
    <a target="_blank" href="https://developer.android.com/guide/topics/data/data-storage.html#filesExternal">Android Official Doc: Using the External Storage</a><br/>
    <a target="_blank" href="https://www.owasp.org/index.php/Mobile_Top_10_2014-M2">OWASP Mobile Top 10 2014-M2: Insecure Data Storage</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/312.html">CWE-312: Cleartext Storage of Sensitive Information</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="ANDROID_BROADCAST"></a>
        <h2 class="page-header">
            ブロードキャスト (Android)
            <a href="#ANDROID_BROADCAST" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>ANDROID_BROADCAST</tt></small></em></p>

        
            
<p>
ブロードキャストインテントは，適切なパーミッションがあれば，どのアプリケーションでも受け取ることができます。可能であれば機密情報を送信しないようにすることをお勧めします。
</p>
<p>
    <b>リスクのあるコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Intent i = new Intent();
i.setAction("com.insecure.action.UserConnected");
i.putExtra("username", user);
i.putExtra("email", email);
i.putExtra("session", newSessionId);

this.sendBroadcast(v1);
</code></pre>
</p>
<br/>
<p>
    <b>解決策 (可能なら):</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Intent i = new Intent();
i.setAction("com.secure.action.UserConnected");

sendBroadcast(v1);
</code></pre>
</p>
<br/>
<p>
    <b>設定 (receiver)<sup>[1] Source: StackOverflow</sup>:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;manifest ...&gt;

    &lt;!-- Permission declaration --&gt;
    &lt;permission android:name="my.app.PERMISSION" /&gt;

    &lt;receiver
        android:name="my.app.BroadcastReceiver"
        android:permission="my.app.PERMISSION"&gt; &lt;!-- Permission enforcement --&gt;
        &lt;intent-filter>
            &lt;action android:name="com.secure.action.UserConnected" /&gt;
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;

    ...
&lt;/manifest>
</code></pre>
</p>
<p>
    <b>設定 (sender)<sup>[1] Source: StackOverflow</sup>:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;manifest&gt;
    &lt;!-- We declare we own the permission to send broadcast to the above receiver --&gt;
    &lt;uses-permission android:name="my.app.PERMISSION"/&gt;

    &lt;!-- With the following configuration, both the sender and the receiver apps need to be signed by the same developer certificate. --&gt;
    &lt;permission android:name="my.app.PERMISSION" android:protectionLevel="signature"/&gt;
&lt;/manifest&gt;
</code></pre>
</p>
<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="https://www.securecoding.cert.org/confluence/display/java/DRD03-J.+Do+not+broadcast+sensitive+information+using+an+implicit+intent">CERT: DRD03-J. Do not broadcast sensitive information using an implicit intent</a><br/>
    <a target="_blank" href="https://developer.android.com/reference/android/content/BroadcastReceiver.html#Security">Android Official Doc: BroadcastReceiver (Security)</a><br/>
    <a target="_blank" href="https://developer.android.com/guide/topics/manifest/receiver-element.html">Android Official Doc: Receiver configuration (see <code>android:permission</code>)</a><br/>
    <sup>[1]</sup> <a target="_blank" href="https://stackoverflow.com/a/21513368/89769">StackOverflow: How to set permissions in broadcast sender and receiver in android</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/925.html">CWE-925: Improper Verification of Intent by Broadcast Receiver</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/927.html">CWE-927: Use of Implicit Intent for Sensitive Communication</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="ANDROID_WORLD_WRITABLE"></a>
        <h2 class="page-header">
            ワールドライタブルファイル (Android)
            <a href="#ANDROID_WORLD_WRITABLE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>ANDROID_WORLD_WRITABLE</tt></small></em></p>

        
            
<p>
このコンテキストで記述されたファイルは，作成モード <code>MODE_WORLD_READABLE</code> を使用しています。
書き込まれたコンテンツが暴露されることは期待した動作ではないかもしれません。
</p>
<p>
    <b>リスクのあるコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>fos = openFileOutput(filename, MODE_WORLD_READABLE);
fos.write(userInfo.getBytes());
</code></pre>
</p>
<br/>
<p>
    <b>解決策 (MODE_PRIVATE の使用):</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>fos = openFileOutput(filename, MODE_PRIVATE);
</code></pre>
</p>
<p>
    <b>解決策 (ローカル SQLite データベースの使用):</b><br/>
おそらく構造化されたデータを格納するための最良の解決策は，ローカルの SQLite データベースを使用することです。
データベースファイルが外部ストレージに作成されていないことを確認してください。実装ガイドラインについては，次の参考文献を参照してください。
</p>
<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="https://www.securecoding.cert.org/confluence/display/java/DRD11-J.+Ensure+that+sensitive+data+is+kept+secure">CERT: DRD11-J. Ensure that sensitive data is kept secure</a><br/>
    <a target="_blank" href="https://developer.android.com/training/articles/security-tips.html#InternalStorage">Android Official Doc: Security Tips</a><br/>
    <a target="_blank" href="https://developer.android.com/reference/android/content/Context.html#MODE_PRIVATE">Android Official Doc: Context.MODE_PRIVATE</a><br/>
    <a target="_blank" href="https://www.vogella.com/tutorials/AndroidSQLite/article.html#databasetutorial_database">vogella.com: Android SQLite database and content provider - Tutorial</a><br/>
    <a target="_blank" href="https://www.vogella.com/tutorials/AndroidSQLite/article.html#databasetutorial_database">vogella.com: Android SQLite database and content provider - Tutorial</a><br/>
    <a target="_blank" href="https://www.owasp.org/index.php/Mobile_Top_10_2014-M2">OWASP Mobile Top 10 2014-M2: Insecure Data Storage</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/312.html">CWE-312: Cleartext Storage of Sensitive Information</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="ANDROID_GEOLOCATION"></a>
        <h2 class="page-header">
            ジオロケーションがアクティブ化された WebView (Android)
            <a href="#ANDROID_GEOLOCATION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>ANDROID_GEOLOCATION</tt></small></em></p>

        
            
<p>
ジオロケーションの取得についてユーザーに確認を求めることをお勧めします。
</p>
<p>
    <b>リスクのあるコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>webView.setWebChromeClient(new WebChromeClient() {
    @Override
    public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) {
        callback.invoke(origin, true, false);
    }
});
</code></pre>
</p>
<p>
    <b>Suggested code:</b><br/>

    ジオロケーションのサンプリングを制限し，ユーザーに確認を求めます。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>webView.setWebChromeClient(new WebChromeClient() {
    @Override
    public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) {
        callback.invoke(origin, true, false);

        //Ask the user for confirmation
    }
});
</code></pre>
</p>
<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="https://www.securecoding.cert.org/confluence/display/java/DRD15-J.+Consider+privacy+concerns+when+using+Geolocation+API">CERT: DRD15-J. Consider privacy concerns when using Geolocation API</a><br/>
    <a target="_blank" href="https://en.wikipedia.org/wiki/W3C_Geolocation_API">Wikipedia: W3C Geolocation API</a><br/>
    <a target="_blank" href="https://w3c.github.io/geolocation-api/">W3C: Geolocation Specification</a><br/>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="ANDROID_WEB_VIEW_JAVASCRIPT"></a>
        <h2 class="page-header">
            JavaScript を有効にした WebView (Android)
            <a href="#ANDROID_WEB_VIEW_JAVASCRIPT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>ANDROID_WEB_VIEW_JAVASCRIPT</tt></small></em></p>

        
            
<p>
WebView で JavaScript を有効にすると XSS の影響を受けやすくなります。潜在的な反映型 XSS，格納型 XSS，DOM XSS についてページレンダリングを検査すべきです。<br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>WebView myWebView = (WebView) findViewById(R.id.webView);
WebSettings webSettings = myWebView.getSettings();
webSettings.setJavaScriptEnabled(true);
</code></pre>
</p>

<p>
    <b>リスクのあるコード:</b><br/>
JavaScript を有効にすることは悪いことではありません。潜在的な XSS に対してバックエンドコードを監査する必要があることを意味します。
XSS は，クライアント側に DOM XSS を導入することもできます。
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>function updateDescription(newDescription) {
    $("#userDescription").html("&lt;p&gt;"+newDescription+"&lt;/p&gt;");
}
</code></pre>
</p>
<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="http://www.technotalkative.com/issue-using-setjavascriptenabled-can-introduce-xss-vulnerabilities-application-review-carefully/">Issue: Using setJavaScriptEnabled can introduce XSS vulnerabilities</a><br/>
    <a target="_blank" href="https://developer.android.com/guide/webapps/webview.html#UsingJavaScript">Android Official Doc: WebView</a><br/>
    <a target="_blank" href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8: Cross Site Scripting</a><br/>
    <a target="_blank" href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP: XSS Prevention Cheat Sheet</a><br/>
    <a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="ANDROID_WEB_VIEW_JAVASCRIPT_INTERFACE"></a>
        <h2 class="page-header">
            JavaScript インタフェースがある WebView (Android)
            <a href="#ANDROID_WEB_VIEW_JAVASCRIPT_INTERFACE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>ANDROID_WEB_VIEW_JAVASCRIPT_INTERFACE</tt></small></em></p>

        
            
<p>
JavaScript インタフェースを使用すると WebView が危険な API にさらされる可能性があります。
WebView で XSS が引き起こされると，そのクラスは悪質な JavaScript コードによって呼び出される可能性があります。
</p>

<p>
    <b>リスクのあるコード:</b><br/>
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>WebView myWebView = (WebView) findViewById(R.id.webView);

myWebView.addJavascriptInterface(new FileWriteUtil(this), "fileWriteUtil");

WebSettings webSettings = myWebView.getSettings();
webSettings.setJavaScriptEnabled(true);

[...]
class FileWriteUtil {
    Context mContext;

    FileOpenUtil(Context c) {
        mContext = c;
    }

    public void writeToFile(String data, String filename, String tag) {
        [...]
    }
}
    </code></pre>
</p>
<br/>
<p>
    <b>参考文献</b><br/>
    <a target="_blank" href="https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface%28java.lang.Object,%20java.lang.String%29">Android Official Doc: <code>WebView.addJavascriptInterface()</code></a><br/>
    <a target="_blank" href="https://cwe.mitre.org/data/definitions/749.html">CWE-749: Exposed Dangerous Method or Function</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="INSECURE_COOKIE"></a>
        <h2 class="page-header">
            Secure フラグがない Cookie 
            <a href="#INSECURE_COOKIE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>INSECURE_COOKIE</tt></small></em></p>

        
            
<p>
<code>Secure</code> フラグが設定されていない新しい Cookie が作成されています。
<code>Secure</code> フラグは安全でない通信 (<code>http://</code>) のために Cookie が送信されないようにするためのブラウザーへの指示です。
</p>

<p>
<b>リスクのあるコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cookie cookie = new Cookie("userName",userName);
response.addCookie(cookie);
</code></pre>
</p>

<p>
<b>解決策 (具体的な設定):</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cookie cookie = new Cookie("userName",userName);
cookie.setSecure(true); // セキュアフラグ
cookie.setHttpOnly(true);
</code></pre>
</p>

<p>
<b>解決策 (Servlet 3.0 の設定):</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" version="3.0"&gt;
[...]
&lt;session-config&gt;
 &lt;cookie-config&gt;
  &lt;http-only&gt;true&lt;/http-only&gt;
  &lt;secure&gt;true&lt;/secure&gt;
 &lt;/cookie-config&gt;
&lt;/session-config&gt;
&lt;/web-app&gt;
</code></pre>
</p>
<br/>
<p>
<b>Reference</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/614.html">CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/315.html">CWE-315: Cleartext Storage of Sensitive Information in a Cookie</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/311.html">CWE-311: Missing Encryption of Sensitive Data</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/SecureFlag">OWASP: Secure Flag</a><br/>
<a target="_blank" href="https://www.rapid7.com/db/vulnerabilities/http-cookie-secure-flag">Rapid7: Missing Secure Flag From SSL Cookie</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="HTTPONLY_COOKIE"></a>
        <h2 class="page-header">
            HttpOnly フラグがない Cookie 
            <a href="#HTTPONLY_COOKIE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>HTTPONLY_COOKIE</tt></small></em></p>

        
            
<p>
<code>HttpOnly</code> が設定されていない新しい Cookie が作成されています。
<code>HttpOnly</code> フラグは，悪意のあるスクリプトによって Cookie が読み取られないようにするためのブラウザーへの指示です。
ユーザーが XSS の対象になっていると，攻撃者はセッション ID を取得するなどの恩恵を得ます。
</p>

<p>
<b>リスクのあるコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cookie cookie = new Cookie("email",userName);
response.addCookie(cookie);
</code></pre>
</p>

<p>
<b>解決策 (具体的な設定):</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Cookie cookie = new Cookie("email",userName);
cookie.setSecure(true);
cookie.setHttpOnly(true); //HttpOnly flag
</code></pre>
</p>

<p>
<b>解決策 (Servlet 3.0 の設定):</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" version="3.0"&gt;
[...]
&lt;session-config&gt;
 &lt;cookie-config&gt;
  &lt;http-only&gt;true&lt;/http-only&gt;
  &lt;secure&gt;true&lt;/secure&gt;
 &lt;/cookie-config&gt;
&lt;/session-config&gt;
&lt;/web-app&gt;
</code></pre>
</p>
<br/>
<p>
<b>Reference</b><br/>
<a target="_blank" href="https://blog.codinghorror.com/protecting-your-cookies-httponly/">Coding Horror blog: Protecting Your Cookies: HttpOnly</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/HttpOnly">OWASP: HttpOnly</a><br/>
<a target="_blank" href="https://www.rapid7.com/db/vulnerabilities/http-cookie-http-only-flag">Rapid7: Missing HttpOnly Flag From Cookie</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="OBJECT_DESERIALIZATION"></a>
        <h2 class="page-header">
            オブジェクトデシリアライズの使用
            <a href="#OBJECT_DESERIALIZATION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>OBJECT_DESERIALIZATION</tt></small></em></p>

        
            
<p>
悪意のある操作のきっかけを許すクラスパスにクラスが存在すると信頼できないデータのオブジェクトのデシリアライズにより，リモートコード実行を引き起こす可能性があります。
</p>
<p>
ライブラリー開発者は，潜在的な悪意のあるトリガーを提供するクラスを修正する傾向があります。
サービス拒否 <sup>[1]</sup> をもたらすことが知られているクラスはまだあります。
</p>
<p>
デシリアライゼーションは，脆弱性の歴史上気を付けなければならない操作です。
Java 仮想マシン <sup>[2] [3]</sup> に新しい脆弱性が見つかるとすぐに，Web アプリケーションが脆弱になる可能性があります。
</p>

<p>
<b>リスクのあるコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public UserData deserializeObject(InputStream receivedFile) throws IOException, ClassNotFoundException {

    try (ObjectInputStream in = new ObjectInputStream(receivedFile)) {
        return (UserData) in.readObject();
    }
}
</code></pre>
</p>

<p>
<b>解決策:</b><br/>
<p>
リモートユーザーが提供するオブジェクトのデシリアライズをしない。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/502.html">CWE-502: Deserialization of Untrusted Data</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Deserialization_of_untrusted_data">Deserialization of untrusted data</a><br/>
<a target="_blank" href="https://www.oracle.com/technetwork/java/seccodeguide-139067.html#8">Serialization and Deserialization </a><br/>
<a target="_blank" href="https://github.com/frohoff/ysoserial">A tool for generating payloads that exploit unsafe Java object deserialization</a><br/>
[1] <a target="_blank" href="https://gist.github.com/coekie/a27cc406fc9f3dc7a70d">Example of Denial of Service using the class <code>java.util.HashSet</code></a><br/>
[2] <a target="_blank" href="https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2015-2590">OpenJDK: Deserialization issue in ObjectInputStream.readSerialData() (CVE-2015-2590)</a><br/>
[3] <a target="_blank" href="https://www.rapid7.com/db/modules/exploit/multi/browser/java_calendar_deserialize">Rapid7: Sun Java Calendar Deserialization Privilege Escalation (CVE-2008-5353)</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="JACKSON_UNSAFE_DESERIALIZATION"></a>
        <h2 class="page-header">
            安全でない Jackson のデシリアライズ設定
            <a href="#JACKSON_UNSAFE_DESERIALIZATION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>JACKSON_UNSAFE_DESERIALIZATION</tt></small></em></p>

        
            
<p>Jackson のデータバインドライブラリーが不正に使用され，悪意のある操作のトリガ-を可能にするクラスパスにクラスがあると
信頼できないデータのデシリアライズによりリモートコード実行を引き起こす可能性があります。</p>
<p>
<b>解決策:</b><br/>
<p>
<code>JsonTypeInfo.Id.NAME</code> を介して多態性を使用するときに使用できるタイプとサブタイプを明示的に定義します。
また，<code>ObjectMapper.enableDefaultTyping</code> を決して呼び出さないでください。(そして，<code>readValue</code> は Object，Serializable，Comparable，または既知のデシリアライズ型を保持します)。
</p>

<p>
<b>リスクのあるコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public class Example {
    static class ABean {
        public int id;
        public Object obj;
    }

    static class AnotherBean {
        @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS) // or JsonTypeInfo.Id.MINIMAL_CLASS
        public Object obj;
    }

    public void example(String json) throws JsonMappingException {
         ObjectMapper mapper = new ObjectMapper();
         mapper.enableDefaultTyping();
         mapper.readValue(json, ABean.class);
    }

    public void exampleTwo(String json) throws JsonMappingException {
         ObjectMapper mapper = new ObjectMapper();
         mapper.readValue(json, AnotherBean.class);
    }

}
</code></pre>
</p>

<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://github.com/FasterXML/jackson-databind/issues/1599">Jackson Deserializer security vulnerability</a><br>
<a target="_blank" href="https://github.com/mbechler/marshalsec">Java Unmarshaller Security - Turning your data into code execution</a><br>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="DESERIALIZATION_GADGET"></a>
        <h2 class="page-header">
            デシリアライゼーションガジェットとして使用できるクラス
            <a href="#DESERIALIZATION_GADGET" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>DESERIALIZATION_GADGET</tt></small></em></p>

        
            
<p>
デシリアライゼーションガジェットは，攻撃者がネイティブシリアライゼーションを使用してリモート API を利用するために使用できるクラスです。
このクラスは，<code>readObject</code> メソッド (シリアライズ可能) を使用してデシリアライズにカスタム動作を追加するかシリアライズされたオブジェクト (InvocationHandler) から呼び出されます。
</p>
<p>
このディテクターは，主に研究者によって使用されることを意図しています。本当に問題なのは，リモート操作にデシリアライズを使用することです。
ガジェットを除去することは，悪用されるリスクを減らすための堅牢な方法です。
</p>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/502.html">CWE-502: Deserialization of Untrusted Data</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Deserialization_of_untrusted_data">Deserialization of untrusted data</a><br/>
<a target="_blank" href="https://www.oracle.com/technetwork/java/seccodeguide-139067.html#8">Serialization and Deserialization </a><br/>
<a target="_blank" href="https://github.com/frohoff/ysoserial">A tool for generating payloads that exploit unsafe Java object deserialization</a><br/>
[1] <a target="_blank" href="https://gist.github.com/coekie/a27cc406fc9f3dc7a70d">Example of Denial of Service using the class <code>java.util.HashSet</code></a><br/>
[2] <a target="_blank" href="https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2015-2590">OpenJDK: Deserialization issue in ObjectInputStream.readSerialData() (CVE-2015-2590)</a><br/>
[3] <a target="_blank" href="https://www.rapid7.com/db/modules/exploit/multi/browser/java_calendar_deserialize">Rapid7: Sun Java Calendar Deserialization Privilege Escalation (CVE-2008-5353)</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="TRUST_BOUNDARY_VIOLATION"></a>
        <h2 class="page-header">
            Trust Boundary Violation
            <a href="#TRUST_BOUNDARY_VIOLATION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>TRUST_BOUNDARY_VIOLATION</tt></small></em></p>

        
            
<p>
「信頼境界は，プログラム内部に引かれた線と考えることができます。線の片側ではデータは信頼できません。線の反対側では，データは信頼できるものと仮定されます。
検証ロジックの目的は，データが信頼境界を安全に越え，信頼できない側から信頼される側に移れるようにすることです。
信頼されているものと信頼されていないものを分ける線がプログラムで不明確なときに，Trust Boundary Violation が発生します。
信頼できるデータと信頼できないデータを同一のデータ構造で混在させることで，プログラマが誤って検証されていないデータを信頼しやすくなります。」 <sup>[1]</sup>
</p>

<p>
<b>リスクのあるコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public void doSomething(HttpServletRequest req, String activateProperty) {
    //..

    req.getSession().setAttribute(activateProperty,"true");

}
</code></pre>
<br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>public void loginEvent(HttpServletRequest req, String userSubmitted) {
    //..

    req.getSession().setAttribute("user",userSubmitted);
}
</code></pre>
</p>

<p>
<b>解決策:</b><br/>
<p>
解決策は，新しいセッション属性を設定する前に検証を追加することです。可能であれば，ダイレクトユーザー入力の使用よりも安全な場所からのデータを選びます。
</p>
<br/>
<p>
<b>参考文献</b><br/>
[1] <a target="_blank" href="https://cwe.mitre.org/data/definitions/501.html">CWE-501: Trust Boundary Violation</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Trust_Boundary_Violation">OWASP : Trust Boundary Violation</a>
</p>

        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="JSP_XSLT"></a>
        <h2 class="page-header">
            悪意のある XSLT が JSP タグに提供される可能性
            <a href="#JSP_XSLT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>JSP_XSLT</tt></small></em></p>

        
            
<p>
「XSLT (Extensible Stylesheet Language Transformations) は，XML 文書を他のXML文書に変換するための言語です。」<sup>[1]</sup><br/>
スタイルシートに悪意のある振る舞いを付けることは可能です。
したがって，攻撃者がスタイルシートの内容やソースを制御できると，リモートコード実行を引き起こすことができます。<sup>[2]</sup>
</p>
<p>
<b>リスクのあるコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&#x3C;x:transform xml=&#x22;${xmlData}&#x22; xslt=&#x22;${xsltControlledByUser}&#x22; /&#x3E;
</code></pre>
</p>
<p>
<b>解決策:</b><br/>
<p>
解決策は，スタイルシートが安全なソースからロードされていることを確認し，パストラバーサル <sup>[3] [4]</sup> のような脆弱性が確実に起こらないようにすることです。
</p>
<p>
<b>参考文献</b><br/>
[1] <a target="_blank" href="https://en.wikipedia.org/wiki/XSLT">Wikipedia: XSLT (Extensible Stylesheet Language Transformations)</a><br/>
<a target="_blank" href="https://prezi.com/y_fuybfudgnd/offensive-xslt/">Offensive XSLT</a> by Nicolas Gregoire<br/>
[2] <a target="_blank" href="https://www.agarri.fr/blog/archives/2012/07/02/from_xslt_code_execution_to_meterpreter_shells/index.html">From XSLT code execution to Meterpreter shells</a> by Nicolas Gregoire<br/>
<a target="_blank" href="https://xhe.myxwiki.org/xwiki/bin/view/Main/">XSLT Hacking Encyclopedia</a> by Nicolas Gregoire<br/>
<a target="_blank" href="https://www.acunetix.com/blog/articles/the-hidden-dangers-of-xsltprocessor-remote-xsl-injection/">Acunetix.com : The hidden dangers of XSLTProcessor - Remote XSL injection</a><br/>
<a target="_blank" href="https://www.w3.org/TR/xslt">w3.org XSL Transformations (XSLT) Version 1.0</a> : w3c specification<br/>
[3] <a target="_blank" href="http://projects.webappsec.org/w/page/13246952/Path%20Traversal">WASC: Path Traversal</a><br/>
[4] <a target="_blank" href="https://www.owasp.org/index.php/Path_Traversal">OWASP: Path Traversal</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="MALICIOUS_XSLT"></a>
        <h2 class="page-header">
            悪意のある XSLT が提供される可能性
            <a href="#MALICIOUS_XSLT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>MALICIOUS_XSLT</tt></small></em></p>

        
            
<p>
「XSLT (Extensible Stylesheet Language Transformations) は，XML 文書を他のXML文書に変換するための言語です。」<sup>[1]</sup><br/>
スタイルシートに悪意のある振る舞いを付けることは可能です。
したがって，攻撃者がスタイルシートの内容やソースを制御できると，リモートコード実行を引き起こせすことができます。<sup>[2]</sup>
</p>
<p>
<b>リスクのあるコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Source xslt = new StreamSource(new FileInputStream(inputUserFile)); // 危険なソース

Transformer transformer = TransformerFactory.newInstance().newTransformer(xslt);

Source text = new StreamSource(new FileInputStream("/data_2_process.xml"));
transformer.transform(text, new StreamResult(...));
</code></pre>
</p>
<p>
<b>解決策:</b><br/>

<p>解決策は，<code>java.lang.Runtime</code> などの Java クラスへの潜在的な参照をブロックする安全な処理モードを有効にすることです。</p>

<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>TransformerFactory factory = TransformerFactory.newInstance();
factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
Source xslt  = new StreamSource(new FileInputStream(inputUserFile));

Transformer transformer = factory.newTransformer(xslt);
</code></pre>

<p>
または，スタイルシートが安全なソースからロードされていることを確認し，パストラバーサル <sup>[3] [4]</sup> のような脆弱性が確実に起こらないようにすることです。
</p>
<p>
<b>参考文献</b><br/>
[1] <a target="_blank" href="https://en.wikipedia.org/wiki/XSLT">Wikipedia: XSLT (Extensible Stylesheet Language Transformations)</a><br/>
<a target="_blank" href="https://prezi.com/y_fuybfudgnd/offensive-xslt/">Offensive XSLT</a> by Nicolas Gregoire<br/>
[2] <a target="_blank" href="https://www.agarri.fr/blog/archives/2012/07/02/from_xslt_code_execution_to_meterpreter_shells/index.html">From XSLT code execution to Meterpreter shells</a> by Nicolas Gregoire<br/>
<a target="_blank" href="https://xhe.myxwiki.org/xwiki/bin/view/Main/">XSLT Hacking Encyclopedia</a> by Nicolas Gregoire<br/>
<a target="_blank" href="https://www.acunetix.com/blog/articles/the-hidden-dangers-of-xsltprocessor-remote-xsl-injection/">Acunetix.com : The hidden dangers of XSLTProcessor - Remote XSL injection</a><br/>
<a target="_blank" href="https://www.w3.org/TR/xslt">w3.org XSL Transformations (XSLT) Version 1.0</a> : w3c specification<br/>
[3] <a target="_blank" href="http://projects.webappsec.org/w/page/13246952/Path%20Traversal">WASC: Path Traversal</a><br/>
[4] <a target="_blank" href="https://www.owasp.org/index.php/Path_Traversal">OWASP: Path Traversal</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SCALA_SENSITIVE_DATA_EXPOSURE"></a>
        <h2 class="page-header">
            Scala Play における潜在的な情報漏洩
            <a href="#SCALA_SENSITIVE_DATA_EXPOSURE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SCALA_SENSITIVE_DATA_EXPOSURE</tt></small></em></p>

        
            
<p>
アプリケーションは，アプリケーションのさまざまな問題により意図せずに設定や内部の動作に関する情報を漏洩したり，プライバシーを侵害する可能性があります。
<sup>[1]</sup> データの正当性に基づいて異なる応答を提供するページは，情報漏洩につながります。具体的には，Web アプリケーションの設計の結果として機密と見なされるデータが漏洩したときです。<sup>[2]</sup>
</p>
<p>
機密データの例には，API キー，パスワード，製品バージョン，環境設定が含まれます (ただしこれに限定されません)。
</p>
<p>
<b>リスクのあるコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>def doGet(value:String) = Action {
  val configElement = configuration.underlying.getString(value)

  Ok("Hello "+ configElement +" !")
}</code></pre>
</p>
<p>
アプリケーション構成要素を応答コンテンツで送信しないでください。また，ユーザーがコードで使用する構成要素を制御できないようにすべきです。
</p>
<b>参考文献</b><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure">OWASP: Top 10 2013-A6-Sensitive Data Exposure</a><br/>
[1] <a target="_blank" href="https://www.owasp.org/index.php/Top_10_2007-Information_Leakage_and_Improper_Error_Handling">OWASP: Top 10 2007-Information Leakage and Improper Error Handling</a><br/>
[2] <a target="_blank" href="http://projects.webappsec.org/w/page/13246936/Information%20Leakage">WASC-13: Information Leakage</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/200.html">CWE-200: Information Exposure</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SCALA_PLAY_SSRF"></a>
        <h2 class="page-header">
            Scala Play Server-Side Request Forgery (SSRF)
            <a href="#SCALA_PLAY_SSRF" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SCALA_PLAY_SSRF</tt></small></em></p>

        
            
<p>
Server-Side Request Forgery (SSRF) は，Web サーバーがユーザーが指定した検証されていない宛先パラメーターへの要求を実行するときに発生します。
このような脆弱性により，攻撃者は内部サービスにアクセスしたり，Web サーバーから攻撃を開始できます。
</p>
<p>
    <b>脆弱なコード:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>def doGet(value:String) = Action {
    WS.url(value).get().map { response =>
        Ok(response.body)
    }
}</code></pre>
</p>
<p>
    <b>解決策/対策:</b><br/>
    <ul>
        <li>ユーザーからリクエスト先を受け入れない</li>
        <li>宛先キーを受け入れ，それを使用して対象の宛先をルックアップする</li>
        <li>URL のホワイトリスト (可能な場合)</li>
        <li>URL の先頭がホワイトリストの一部であることを検証する</li>
    </ul>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/918.html">CWE-918: Server-Side Request Forgery (SSRF)</a><br/>
<a target="_blank" href="https://www.bishopfox.com/blog/2015/04/vulnerable-by-design-understanding-server-side-request-forgery/">Understanding Server-Side Request Forgery</a><br/>
</p>
            

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="URLCONNECTION_SSRF_FD"></a>
        <h2 class="page-header">
            URLConnection Server-Side Request Forgery (SSRF) と File Disclosure
            <a href="#URLCONNECTION_SSRF_FD" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>URLCONNECTION_SSRF_FD</tt></small></em></p>

        
            
<p>
Server-Side Request Forgery (SSRF) は，Web サーバーがユーザーが指定した検証されていない宛先パラメーターへの要求を実行するときに発生します。
このような脆弱性により，攻撃者は内部サービスにアクセスしたり，Web サーバーから攻撃を開始できます。
</p>
<p>
URLConnection は，file：// プロトコルまたは他のプロトコルと共に使用して，ローカルファイルシステムやその他のサービスにアクセスできます。
<p>
    <b>脆弱なコード:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>new URL(String url).openConnection()
</code></pre>

<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>new URL(String url).openStream()
</code></pre>

<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>new URL(String url).getContent()
</code></pre>
</p>
<p>
    <b>解決策/対策:</b><br/>
    <ul>
        <li>ユーザーから URL 宛先を受け入れない</li>
        <li>宛先キーを受け入れ，それを使用して対象 (合法) の宛先をルックアップする</li>
        <li>URL のホワイトリスト (可能な場合)</li>
        <li>URL の先頭がホワイトリストの一部であることを検証する</li>
    </ul>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/918.html">CWE-918: Server-Side Request Forgery (SSRF)</a><br/>
<a target="_blank" href="https://www.bishopfox.com/blog/2015/04/vulnerable-by-design-understanding-server-side-request-forgery/">Understanding Server-Side Request Forgery</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/73.html">CWE-73: External Control of File Name or Path</a><br/>
<a target="_blank" href="https://www.pwntester.com/blog/2013/11/28/abusing-jar-downloads/">Abusing jar:// downloads</a><br/>
</p>
            

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SCALA_XSS_TWIRL"></a>
        <h2 class="page-header">
            Scala Twirl テンプレートエンジンの潜在的な XSS
            <a href="#SCALA_XSS_TWIRL" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SCALA_XSS_TWIRL</tt></small></em></p>

        
            
<p>
潜在的な XSS を発見しました。クライアントのブラウザーで望まれていない JavaScript を実行するために使用される可能性があります。(参考文献を参照)
</p>
<p>
    <b>脆弱なコード:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>@(value: Html)

@value</code></pre>
</p>
<p>
    <b>解決策:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>@(value: String)

@value</code></pre>
</p>
<p>
XSS に対する最善の防御は，上記の例のような特定の状況で使える出力エンコーディングです。考慮すべきコンテキストは4つあります: HTML，JavaScript，CSS (スタイル)，URL です。
OWASP XSS Prevention Cheat Sheet で定義されている XSS 保護ルールに従ってください。これらの防御について詳細に説明しています。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8: Cross Site Scripting</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP: XSS Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a><br/>
<a target="_blank" href="https://code.google.com/p/owasp-java-encoder/">OWASP Java Encoder</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SCALA_XSS_MVC_API"></a>
        <h2 class="page-header">
            Scala MVC API エンジンの潜在的な XSS
            <a href="#SCALA_XSS_MVC_API" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SCALA_XSS_MVC_API</tt></small></em></p>

        
            
<p>
潜在的な XSS を発見しました。クライアントのブラウザーで望まれていない JavaScript を実行するために使用される可能性があります。(参考文献を参照)
</p>
<p>
    <b>脆弱なコード:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>def doGet(value:String) = Action {
    Ok("Hello " + value + " !").as("text/html")
  }</code></pre>
</p>
<p>
    <b>解決策:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>def doGet(value:String) = Action {
    Ok("Hello " + Encode.forHtml(value) + " !")
  }</code></pre>
</p>
<p>
XSSに対する最善の防御は，上記の例のような特定の状況で使える出力エンコーディングです。考慮すべきコンテキストは4つあります: HTML，JavaScript，CSS (スタイル)，URL です。
OWASP XSS Prevention Cheat Sheet で定義されている XSS 保護ルールに従ってください。これらの防御について詳細に説明しています。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8: Cross Site Scripting</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP: XSS Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a><br/>
<a target="_blank" href="https://code.google.com/p/owasp-java-encoder/">OWASP Java Encoder</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="TEMPLATE_INJECTION_VELOCITY"></a>
        <h2 class="page-header">
            Velocity の潜在的なテンプレートインジェクション
            <a href="#TEMPLATE_INJECTION_VELOCITY" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>TEMPLATE_INJECTION_VELOCITY</tt></small></em></p>

        
            
<p>
Velocity テンプレートエンジンは強力です。条件文，ループ，外部呼び出しなどのロジックを追加することができます。
テンプレート操作をサンドボックスにすることは設計されていません。テンプレートを制御する悪意のあるユーザーは，サーバー側で悪意のあるコードを実行する可能性があります。
Velocity テンプレートはスクリプトとしてみなすべきです。
</p>
<p>
    <b>脆弱なコード:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>[...]

Velocity.evaluate(context, swOut, "test", userInput);</code></pre>
</p>
<p>
    <b>解決策:</b>
<br/>
エンドユーザーが Velocity を使用してテンプレートを操作できないようにします。
テンプレート編集をユーザーに公開する必要があるときは，Handlebars や Mustache などのロジックレステンプレートエンジンを使用することをお勧めします。(参考文献を参照)
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://blog.portswigger.net/2015/08/server-side-template-injection.html">PortSwigger: Server-Side Template Injection </a><br/>
<a target="_blank" href="https://jknack.github.io/handlebars.java/">Handlebars.java</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="TEMPLATE_INJECTION_FREEMARKER"></a>
        <h2 class="page-header">
            Freemarker の潜在的なテンプレートインジェクション
            <a href="#TEMPLATE_INJECTION_FREEMARKER" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>TEMPLATE_INJECTION_FREEMARKER</tt></small></em></p>

        
            
<p>
Freemarker テンプレートエンジンは強力です。条件文，ループ，外部呼び出しなどのロジックを追加することができます。
テンプレート操作をサンドボックスにすることは設計されていません。テンプレートを制御する悪意のあるユーザーは，サーバー側で悪意のあるコードを実行する可能性があります。
Freemarker テンプレートはスクリプトとして見なすべきです。
</p>
<p>
    <b>脆弱なコード:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Template template = cfg.getTemplate(inputTemplate);
[...]
template.process(data, swOut);</code></pre>
</p>
<p>
    <b>解決策:</b>
<br/>
エンドユーザーが Freemarker を使用してテンプレートを操作できないようにします。
テンプレート編集をユーザーに公開する必要があるときは，Handlebars や Mustache などのロジックレステンプレートエンジンを使用することをお勧めします。(参考文献を参照)
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://portswigger.net/research/server-side-template-injection">PortSwigger: Server-Side Template Injection</a><br/>
<a target="_blank" href="https://jknack.github.io/handlebars.java/">Handlebars.java</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="TEMPLATE_INJECTION_PEBBLE"></a>
        <h2 class="page-header">
            Pebble の潜在的なテンプレートインジェクション
            <a href="#TEMPLATE_INJECTION_PEBBLE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>TEMPLATE_INJECTION_PEBBLE</tt></small></em></p>

        
            
<p>
Pebble テンプレートエンジンは強力です。条件文，ループ，外部呼び出しなどのロジックを追加することができます。
テンプレート操作をサンドボックスにすることは設計されていません。テンプレートを制御する悪意のあるユーザーは，サーバー側で悪意のあるコードを実行する可能性があります。
Pebble テンプレートはスクリプトとして見なすべきです。
</p>
<p>
    <b>脆弱なコード:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>PebbleTemplate compiledTemplate = engine.getLiteralTemplate(inputFile);
[...]
compiledTemplate.evaluate(writer, context);</code></pre>
</p>
<p>
    <b>解決策:</b>
<br/>
エンドユーザーが Pebble を使用してテンプレートを操作できないようにします。
テンプレート編集をユーザーに公開する必要があるときは，Handlebars や Mustache などのロジックレステンプレートエンジンを使用することをお勧めします。(参考文献を参照)
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://research.securitum.com/server-side-template-injection-on-the-example-of-pebble/">Server Side Template Injection ? on the example of Pebble</a> by Micha? Bentkowski<br/>
<a target="_blank" href="https://portswigger.net/research/server-side-template-injection">PortSwigger: Server-Side Template Injection</a><br/>
<a target="_blank" href="https://jknack.github.io/handlebars.java/">Handlebars.java</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="PERMISSIVE_CORS"></a>
        <h2 class="page-header">
            過剰に許可された CORS ポリシー
            <a href="#PERMISSIVE_CORS" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>PERMISSIVE_CORS</tt></small></em></p>

        
            
<p>
HTML5 以前の Web ブラウザーでは，同一生成元ポリシーが強制されます。このポリシーは，JavaScript  が Web  ページのコンテンツにアクセスするために，JavaScript と Web  ページの両方が同じドメインを由来としていなければなりません。
同一生成元ポリシーが適用されないと，悪意のある Web サイトはクライアントの認証情報を使用して他の Web サイトから機密情報をロードする JavaScript を仕込むことができ，選び取った情報を攻撃者に返します。
Access-Control-Allow-Origin という新しい HTTP ヘッダーが定義されていると，HTML5 では，JavaScript はドメイン間でデータにアクセスすることが可能です。
生成元間のリクエストを使用してドメインにアクセスすることを許可する他のドメインを，Web サーバーはこのヘッダーを使用して定義します。
しかし，このヘッダーを定義する場合には，注意が必要です。過剰に許可された CORS ポリシーは，悪意のあるアプリケーションが不正な方法で攻撃対象のアプリケーションとやりとりをして，偽装，データの盗み出し，リレー，およびその他の攻撃が実行される恐れがあります。
</p>
<p>
    <b>脆弱なコード:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>response.addHeader("Access-Control-Allow-Origin", "*");</code></pre>
</p>
<p>
    <b>解決策:</b>
<br/>
Access Control-Allow-Origin ヘッダーの値としてワイルドカード (*) を使用しないでください。アプリケーションのデータが，任意のドメインで実行される JavaScript  にアクセスできることになります。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://www.w3.org/TR/cors/">W3C Cross-Origin Resource Sharing</a><br/>
<a target="_blank" href="https://enable-cors.org/">Enable Cross-Origin Resource Sharing</a><br/>
</p>
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="LDAP_ANONYMOUS"></a>
        <h2 class="page-header">
            匿名 LDAP バインド
            <a href="#LDAP_ANONYMOUS" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>LDAP_ANONYMOUS</tt></small></em></p>

        
            
<p>
適切なアクセス制御がなく，ユーザーの制御下にある値を含む LDAP ステートメントを実行すると，攻撃者は不適切な設定となっている LDAP コンテキストを悪用できます。
コンテキストに対するすべての LDAP クエリーは，認証とアクセス制御なしで実行されます。
攻撃者は，これらのクエリーのいずれかを予期せぬ方法で操作して，ディレクトリーのアクセス制御メカニズムにより保護されているレコードにアクセスすることができます。
</p>
<p>
    <b>脆弱なコード:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>...
env.put(Context.SECURITY_AUTHENTICATION, "none");
DirContext ctx = new InitialDirContext(env);
...</code></pre>
</p>
<p>
    <b>解決策:</b>
<br/>
LDAP に対する他の認証モードを検討し，適切なアクセス制御メカニズムを確保してください。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://docs.oracle.com/javase/tutorial/jndi/ldap/auth_mechs.html">Ldap Authentication Mechanisms</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="LDAP_ENTRY_POISONING"></a>
        <h2 class="page-header">
            LDAP Entry Poisoning
            <a href="#LDAP_ENTRY_POISONING" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>LDAP_ENTRY_POISONING</tt></small></em></p>

        
            
<p>
JNDI API は，LDAP ディレクトリー内のシリアライズオブジェクトのバインディングをサポートします。
特定の属性が提示されていると，オブジェクトのデシリアライズは，ディレクトリーを照会するアプリケーションで行われます (詳細は Black Hat USA 2016ホワイトペーパーを参照)。
オブジェクトのデシリアライズは，リモートコード実行につながる可能性のある危険な操作であることを考慮すべきです。
</p>
<p>
LDAP ベースクエリーにエントリポイントを持っていると，攻撃者が既存の LDAP エントリに属性を追加するか，悪意のある LDAP サーバーを使用するようにアプリケーションを構成することにより，この脆弱性が悪用される可能性があります。
</p>
<p>
    <b>脆弱なコード:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>DirContext ctx = new InitialDirContext();
//[...]

ctx.search(query, filter,
        new SearchControls(scope, countLimit, timeLimit, attributes,
            true, //Enable object deserialization if bound in directory
            deref));
</code></pre>
</p>
<p>
    <b>解決策:</b>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>DirContext ctx = new InitialDirContext();
//[...]

ctx.search(query, filter,
        new SearchControls(scope, countLimit, timeLimit, attributes,
            false, //Disable
            deref));
</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf">Black Hat USA 2016: A Journey From JNDI/LDAP Manipulation to Remote Code Execution Dream Land</a>
(<a target="_blank" href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf">slides</a> &amp; <a target="_blank" href="https://www.youtube.com/watch?v=Y8a5nB-vy78">video</a>) by Alvaro Mu&#xF1;oz and Oleksandr Mirosh<br/>
<a target="_blank" href="https://community.hpe.com/t5/Security-Research/Introducing-JNDI-Injection-and-LDAP-Entry-Poisoning/ba-p/6885118">HP Enterprise: Introducing JNDI Injection and LDAP Entry Poisoning</a> by Alvaro Mu&#xF1;oz<br/>
<a target="_blank" href="http://blog.trendmicro.com/trendlabs-security-intelligence/new-headaches-how-the-pawn-storm-zero-day-evaded-javas-click-to-play-protection/">TrendMicro: How The Pawn Storm Zero-Day Evaded Java's Click-to-Play Protection</a> by Jack Tang
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="COOKIE_PERSISTENT"></a>
        <h2 class="page-header">
            永続的 Cookie の使用
            <a href="#COOKIE_PERSISTENT" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>COOKIE_PERSISTENT</tt></small></em></p>

        
            
<p>
永続的 Cookie に機密データーを長期間保管すると，機密性が損なわれたり，アカウントが悪用される可能性があります。
</p>
<p>
    <b>説明:</b><br/>
永続的 Cookie では有効期限がずっと先に設定されることが多いため，永続的 Cookie に個人情報が保管されていると，攻撃者が情報を盗み出すことのできる時間が長くなります。
永続的 Cookie は通常，クライアント上のテキストファイルに保存され，被害者のマシンにアクセスできる攻撃者はこの情報を盗むことができます。<br/>
永続的 Cookie は，サイトとやり取りするときのユーザープロファイルとして使用されます。
この追跡データに対して実行される操作によっては，ユーザーの個人情報を盗み出すのに永続的 Cookie が使用される可能性があります。
</p>
<p>
    <b>脆弱なコード:</b> 次のコードは，Cookie が1年間で期限切れになるよう設定します。<br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>[...]
Cookie cookie = new Cookie("email", email);
cookie.setMaxAge(60*60*24*365);
[...]</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
<ul>
    <li>永続的 Cookie は，必要なときにだけ使用し，最大有効期間を制限する</li>
    <li>重要なデータに永続的 Cookie を使用しない</li>
</ul>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/Cookie.html#setMaxAge%28int%29">Class Cookie <code>setMaxAge</code> documentation</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/539.html">CWE-539: Information Exposure Through Persistent Cookies</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="URL_REWRITING"></a>
        <h2 class="page-header">
            URL を書き換えるメソッド
            <a href="#URL_REWRITING" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>URL_REWRITING</tt></small></em></p>

        
            
<p>
このメソッドの実装には，セッション ID を URL にエンコードする必要があるかどうかを判断するロジックが含まれています。<br/>
URL の書き換えには，セキュリティ上の重大なリスクがあります。セッション ID が URL に表示されるので，第三者が容易に見ることができます。
URL のセッション ID は，さまざまな方法で公開できます。たとえば，次のようになります。<br/>
<ul>
    <li>ログファイル</li>
    <li>ブラウザーの履歴</li>
    <li>電子メールや投稿にコピーアンドペーストすることにより</li>
    <li>HTTP のリファラー</li>
</ul>
</p>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>out.println("Click &lt;a href=" +
                res.encodeURL(HttpUtils.getRequestURL(req).toString()) +
                "&gt;here&lt;/a&gt;");</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
これらのメソッドを使用しないでください。URL 文字列またはフォームパラメーターをエンコードするときは，URL を書き換えるメソッドと URLEncoder クラスを混同しないでください。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2010-A3-Broken_Authentication_and_Session_Management">OWASP Top 10 2010-A3-Broken Authentication and Session Management</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="INSECURE_SMTP_SSL"></a>
        <h2 class="page-header">
            安全でない SMTP SSL 接続
            <a href="#INSECURE_SMTP_SSL" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>INSECURE_SMTP_SSL</tt></small></em></p>

        
            
<p>
SSL 接続を確立すると，サーバー ID の確認は無効になります。SSL 接続を有効にする電子メールライブラリーによっては，デフォルトでサーバー証明書を検証しません。
これは，すべての証明書を信頼することと同じです。サーバーに接続しようとすると，このアプリケーションは "victim.com" に対して発行された証明書をすぐに受け入れます。
アプリケーションは，victim サーバーへの不正な SSL接続によって，ユーザー機密情報を漏洩させる可能性があります。
</p>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>...
Email email = new SimpleEmail();
email.setHostName("smtp.servermail.com");
email.setSmtpPort(465);
email.setAuthenticator(new DefaultAuthenticator(username, password));
email.setSSLOnConnect(true);
email.setFrom("user@gmail.com");
email.setSubject("TestMail");
email.setMsg("This is a test mail ... :-)");
email.addTo("foo@bar.com");
email.send();
...</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
次のチェックを追加してサーバ証明書を確認してください:
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>email.setSSLCheckServerIdentity(true);</code></pre>
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/297.html">CWE-297: Improper Validation of Certificate with Host Mismatch</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="AWS_QUERY_INJECTION"></a>
        <h2 class="page-header">
            AWS Query インジェクション
            <a href="#AWS_QUERY_INJECTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>AWS_QUERY_INJECTION</tt></small></em></p>

        
            
<p>
ユーザー入力を含む SimpleDB クエリーを構築すると，攻撃者が権限のないレコードを閲覧できます。<br/>
次の例では，ユーザーが productCategory を指定できるようにする SimpleDB SELECT クエリーを動的に構築して実行します。
攻撃者は，クエリーを変更し，customerID に必要な認証を回避し，任意の顧客に一致するレコードを表示できます。
</p>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>...
String customerID = getAuthenticatedCustomerID(customerName, customerCredentials);
String productCategory = request.getParameter("productCategory");
...
AmazonSimpleDBClient sdbc = new AmazonSimpleDBClient(appAWSCredentials);
String query = "select * from invoices where productCategory = '"
            + productCategory + "' and customerID = '"
            + customerID + "' order by '"
            + sortColumn + "' asc";
SelectResult sdbResult = sdbc.select(new SelectRequest(query));
</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
この問題は SQL インジェクションに似ています。SimpleDB クエリーを使用する前にユーザー入力をエスケープします。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/943.html">CWE-943: Improper Neutralization of Special Elements in Data Query Logic</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="BEAN_PROPERTY_INJECTION"></a>
        <h2 class="page-header">
            JavaBeans プロパティインジェクション
            <a href="#BEAN_PROPERTY_INJECTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>BEAN_PROPERTY_INJECTION</tt></small></em></p>

        
            
<p>
攻撃者は，システムの整合性を損なう任意の Bean プロパティを設定できます。Bean 入力機能は，Bean プロパティまたはネストされたプロパティを設定できます。
攻撃者がこの機能を利用して，システムプロパティを上書きして任意のコードを実行できるようにする <code>class.classLoader</code> のような特殊な Bean プロパティにアクセスする可能性があります。
</p>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>MyBean bean = ...;
HashMap map = new HashMap();
Enumeration names = request.getParameterNames();
while (names.hasMoreElements()) {
    String name = (String) names.nextElement();
    map.put(name, request.getParameterValues(name));
}
BeanUtils.populate(bean, map);</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
ユーザーが制御する値を使用して Bean プロパティ名を設定しないでください。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/15.html">CWE-15: External Control of System or Configuration Setting</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="STRUTS_FILE_DISCLOSURE"></a>
        <h2 class="page-header">
            Struts File Disclosure
            <a href="#STRUTS_FILE_DISCLOSURE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>STRUTS_FILE_DISCLOSURE</tt></small></em></p>

        
            
<p>
ユーザー入力を使用してサーバーサイドリダイレクトパスを作成すると，攻撃者にアプリケーションのバイナリ (アプリケーションクラスや jar ファイルを含む) をダウンロードされたり保護されているディレクトリ内の任意のファイルを表示されたりする可能性があります。<br/>
攻撃者は，重要なファイルの場所と一致するリクエストパラメーターを偽造できます。
たとえば，<code>"http://example.com/?returnURL=WEB-INF/applicationContext.xml"</code> を要求すると，アプリケーションの <code>applicationContext.xml</code> ファイルが表示されます。
攻撃者は，他の構成ファイル，クラスファイル，jar ファイルで参照されている <code>applicationContext.xml</code> を見つけてダウンロードし，機密情報を取得して他の種類の攻撃を開始できます。
</p>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>...
String returnURL = request.getParameter("returnURL");
Return new ActionForward(returnURL);
...</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
ユーザーが制御する入力を使用してサーバーサイドリダイレクトを構成しないでください。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/552.html">CWE-552: Files or Directories Accessible to External Parties</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SPRING_FILE_DISCLOSURE"></a>
        <h2 class="page-header">
            Spring File Disclosure
            <a href="#SPRING_FILE_DISCLOSURE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SPRING_FILE_DISCLOSURE</tt></small></em></p>

        
            
<p>
ユーザー入力を使用してサーバーサイドリダイレクトパスを作成すると，攻撃者にアプリケーションのバイナリ (アプリケーションクラスや jar ファイルを含む) をダウンロードされたり保護されているディレクトリ内の任意のファイルを表示されたりする可能性があります。<br/>
攻撃者は，重要なファイルの場所と一致するリクエストパラメーターを偽造できます。
たとえば，<code>"http://example.com/?jspFile=../applicationContext.xml%3F"</code> を要求すると，アプリケーションの <code>applicationContext.xml</code> ファイルが表示されます。
攻撃者は，他の構成ファイル，クラスファイル，jar ファイルで参照されている <code>applicationContext.xml</code> を見つけてダウンロードし，機密情報を取得して他の種類の攻撃を開始できます。
</p>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>...
String returnURL = request.getParameter("returnURL");
return new ModelAndView(returnURL);
...</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
ユーザーが制御する入力を使用してサーバーサイドリダイレクトを構成しないでください。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/552.html">CWE-552: Files or Directories Accessible to External Parties</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="REQUESTDISPATCHER_FILE_DISCLOSURE"></a>
        <h2 class="page-header">
            RequestDispatcher File Disclosure
            <a href="#REQUESTDISPATCHER_FILE_DISCLOSURE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>REQUESTDISPATCHER_FILE_DISCLOSURE</tt></small></em></p>

        
            
<p>
ユーザー入力を使用してサーバーサイドリダイレクトパスを作成すると，攻撃者にアプリケーションのバイナリ (アプリケーションクラスや jar ファイルを含む) をダウンロードされたり保護されているディレクトリ内の任意のファイルを表示されたりする可能性があります。<br/>
攻撃者は，重要なファイルの場所と一致するリクエストパラメーターを偽造できます。
たとえば，<code>"http://example.com/?jspFile=../applicationContext.xml%3F"</code> を要求すると，アプリケーションの <code>applicationContext.xml</code> ファイルが表示されます。
攻撃者は，他の構成ファイル，クラスファイル，jar ファイルで参照されている <code>applicationContext.xml</code> を見つけてダウンロードし，機密情報を取得して他の種類の攻撃を開始できます。
</p>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>...
String jspFile = request.getParameter("jspFile");
request.getRequestDispatcher("/WEB-INF/jsps/" + jspFile + ".jsp").include(request, response);
...</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
ユーザーが制御する入力を使用してサーバーサイドリダイレクトを構成しないでください。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/552.html">CWE-552: Files or Directories Accessible to External Parties</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="FORMAT_STRING_MANIPULATION"></a>
        <h2 class="page-header">
            書式文字列操作
            <a href="#FORMAT_STRING_MANIPULATION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>FORMAT_STRING_MANIPULATION</tt></small></em></p>

        
            
<p>
ユーザー入力で書式パラメーターが制御できるようになっていると，攻撃者が例外を投げたり情報を漏洩させたりすることができます。<br/>
攻撃者は，書式文字列の引数を変更して，例外がスローされるようにすることができます。この例外がキャッチされなかった場合，アプリケーションがクラッシュする可能性があります。
あるいは，未使用の引数内で機密情報が使用されると，攻撃者はこの情報を暴露するために書式文字列を変更できます。<br/>
次のコード例では，残高を示す小数点をユーザーが指定できます。実際には，例外がスローされる原因となるものを指定することができ，アプリケーションの障害を引き起こす可能性があります。
この例ではさらに重要なことに，攻撃者がユーザー入力 <code>"2f %3$s %4$.2"</code> を指定できると，書式文字列は <code>"The customer: %s %s has the balance %4$.2f %3$s %4$.2"</code> となります。
これにより，結果文字列に機密の <code>accountNo</code> が含まれることになります。
</p>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Formatter formatter = new Formatter(Locale.US);
String format = "The customer: %s %s has the balance %4$." + userInput + "f";
formatter.format(format, firstName, lastName, accountNo, balance);</code></pre>
</p>
<p>
    <b>解決策:</b><br/>
書式文字列引数にユーザーが制御する値を使用しないでください。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/134.html">CWE-134: Use of Externally-Controlled Format String</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="HTTP_PARAMETER_POLLUTION"></a>
        <h2 class="page-header">
            HTTP Parameter Pollution
            <a href="#HTTP_PARAMETER_POLLUTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>HTTP_PARAMETER_POLLUTION</tt></small></em></p>

        
            
<p>
未検証のユーザー入力を URL に連結すると，攻撃者にリクエストパラメーターの値の上書きを許します。
攻撃者が，既存のパラメーターの値を上書きしたり，新しいパラメーターを挿入したり，直接到達できない変数を利用したりすることができます。
HTTP Parameter Pollution (HPP) 攻撃は，エンコードしたクエリー文字列区切り文字を他の既存のパラメーターに挿入することで成り立ちます。
Web アプリケーションがユーザー入力を適切にエスケープしていないと，悪意のあるユーザーがアプリケーションのロジックを侵害して，クライアント側またはサーバー側の攻撃を実行する可能性があります。<br/>
次の例では，プログラマは，攻撃者が <code>en&user_id=1</code> のような <code>lang</code> を指定できる可能性を考慮していないため，攻撃者が思いのままに <code>user_id</code> を変更できます。
</p>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>String lang = request.getParameter("lang");
GetMethod get = new GetMethod("http://www.host.com");
get.setQueryString("lang=" + lang + "&user_id=" + user_id);
get.execute();</code></pre>
<p>
    <b>解決策:</b><br/>
HTTP パラメーターで使用する前にユーザー入力をエスケープします。
</p>
<br/>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://capec.mitre.org/data/definitions/460.html">CAPEC-460: HTTP Parameter Pollution (HPP)</a>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE"></a>
        <h2 class="page-header">
            エラーメッセージによる情報漏洩
            <a href="#INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE</tt></small></em></p>

        
            
<p>
機密情報は，それ自体で貴重な情報（パスワードなど）である場合もあれば他のより致命的な攻撃を仕かけるのに役立つ場合もあります。
攻撃が失敗した場合，攻撃者はサーバーから提供されたエラー情報を使用して，より焦点を絞った別の攻撃を開始できます。
たとえば，パストラバーサルの弱点 (CWE-22) を悪用しようとするとインストールされているアプリケーションの完全パス名が得られる可能性があります。
次に，これを使用して，適切な数の「..」シーケンスを選択し，ターゲットファイルに移動します。
SQLインジェクション (CWE-89) を使用した攻撃は，最初は成功しないかもしれませんが，エラーメッセージによって不正なクエリが明らかになり，クエリロジック，さらにはクエリ内で使用されるパスワードやその他の機密情報が明らかになる可能性があります。
</p>
<p>
    <b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>try {
  out = httpResponse.getOutputStream()
} catch (Exception e) {
  e.printStackTrace(out);
}</code></pre>
</p>
<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/209.html">CWE-209: Information Exposure Through an Error Message</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/211.html">CWE-211: Information Exposure Through Externally-Generated Error Message</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SMTP_HEADER_INJECTION"></a>
        <h2 class="page-header">
            SMTP ヘッダーインジェクション
            <a href="#SMTP_HEADER_INJECTION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SMTP_HEADER_INJECTION</tt></small></em></p>

        
            
<p>
Simple Mail Transfer Protocol (SMTP) は，電子メール配信に使用されるテキストベースのプロトコルです。
HTTP と同様に，ヘッダーは改行で区切られます。
ユーザ入力がヘッダー行にある場合，アプリケーションは改行文字 (<code>CR</code> / <code>LF</code>) を削除または置換すべきです。
<a target="_blank" href="https://commons.apache.org/proper/commons-email/userguide.html">Apache Common Email</a> や <a target="_blank" href="http://www.simplejavamail.org">Simple Java Mail</a> などの安全なラッパーを使用して，ヘッダーインジェクションにつながる特殊文字をフィルタすべきです。
</p>
    <b>脆弱なコード:</b><br/>
<p>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Message message = new MimeMessage(session);
message.setFrom(new InternetAddress("noreply@your-organisation.com"));
message.setRecipients(Message.RecipientType.TO, new InternetAddress[] {new InternetAddress("target@gmail.com")});
message.setSubject(usernameDisplay + " has sent you notification"); //Injectable API
message.setText("Visit your ACME Corp profile for more info.");
Transport.send(message);
</code></pre>
</p>
    <b>解決策</b><br/>
<p>Use <a target="_blank" href="https://commons.apache.org/proper/commons-email/userguide.html">Apache Common Email</a> or <a target="_blank" href="http://www.simplejavamail.org">Simple Java Mail</a>.</p>

<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Testing_for_IMAP/SMTP_Injection_(OTG-INPVAL-011)">OWASP SMTP Injection</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/93.html">CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')</a><br/>
<a target="_blank" href="https://commons.apache.org/proper/commons-email/userguide.html">Commons Email: User Guide</a><br/>
<a target="_blank" href="http://www.simplejavamail.org">Simple Java Mail Website</a><br/>
<a target="_blank" href="https://security.stackexchange.com/a/54100/24973">StackExchange InfoSec: What threats come from CRLF in email generation?</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="RPC_ENABLED_EXTENSIONS"></a>
        <h2 class="page-header">
            有効なApache XML RPC サーバーまたはクライアントの拡張機能
            <a href="#RPC_ENABLED_EXTENSIONS" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>RPC_ENABLED_EXTENSIONS</tt></small></em></p>

        
            
<p>
Apache XML RPCサーバーまたはクライアントで拡張機能を有効にすると，デシリアライズの脆弱性が発生する可能性があります。
これにより，攻撃者が任意のコードを実行することができるようになります。
<br/>
<code>org.apache.xmlrpc.client.XmlRpcClientConfigImpl</code> または <code>org.apache.xmlrpc.XmlRpcConfigImpl</code> の <code>setEnabledForExtensions</code> メソッドを使用しないことをお勧めします。
デフォルトでは，拡張機能はクライアントとサーバーの両方で無効になっています。
</p>

<p>
<b>参考文献</b><br/>

<a target="_blank" href="https://0ang3el.blogspot.com/2016/07/beware-of-ws-xmlrpc-library-in-your.html">0ang3el's Blog: Beware of WS-XMLRPC library in your Java App</a><br/>
<a target="_blank" href="https://nvd.nist.gov/vuln/detail/CVE-2016-5003">CVE-2016-5003 vulnerability reference</a><br/>
</p>
            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="WICKET_XSS1"></a>
        <h2 class="page-header">
            HTMLエスケープを無効にすると，アプリケーションが XSS の危険にさらされる
            <a href="#WICKET_XSS1" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>WICKET_XSS1</tt></small></em></p>

        
            
<p>
HTMLエスケープを無効にすると，アプリケーションがクロスサイトスクリプティング (XSS) の危険にさらされます。
</p>
<p>
<b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>add(new Label("someLabel").setEscapeModelStrings(false));
</code></pre>
</p>

<p>
<b>参考文献</b><br/>

<a target="_blank" href="https://ci.apache.org/projects/wicket/guide/6.x/guide/modelsforms.html">Wicket models and forms - Reference Documentation</a><br/>
<a target="_blank" href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8: Cross Site Scripting</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP: XSS Prevention Cheat Sheet</a><br/>
<a target="_blank" href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a>
</p>


            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="SAML_IGNORE_COMMENTS"></a>
        <h2 class="page-header">
            SAML で XML コメントを無視すると，認証バイパスが発生する可能性がある
            <a href="#SAML_IGNORE_COMMENTS" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>SAML_IGNORE_COMMENTS</tt></small></em></p>

        
            
<p>
Security Assertion Markup Language (SAML) は，XML を使用したシングルサインオンプロトコルです。
SAMLResponse メッセージには，認証されたユーザーを記述するステートメントが含まています
ユーザーが XML コメント (<code>&lt;!-- --&gt;</code>) を配置すると，パーサーがリテラル値を抽出する方法で問題が発生する可能性があります。
</p>

<p>
    たとえば，次の XML セクションを見てみましょう:
    <pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>&lt;saml:Subject&gt;&lt;saml:NameID&gt;admin@domain.com&lt;!----&gt;.evil.com&lt;/saml:NameID&gt;&lt;/saml:Subject&gt;</code></pre>

    ユーザー ID は，<code>"admin@domain.com&lt;!----&gt;.evil.com"</code> ですが，実際にはテキストノード <code>"admin@domain.com"</code>，コメント <code>""</code>，テキストノード <code>".evil.com"</code> です。
    NameID を抽出すると，サービスプロバイダーの実装は，最初のノードまたは最後のノードとなることがあります。
</p>

<p>
<b>脆弱なコード:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>@Bean
ParserPool parserPool1() {
    BasicParserPool pool = new BasicParserPool();
    pool.setIgnoreComments(false);
    return pool;
}
</code></pre>
</p>

<p>
<b>解決策:</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>@Bean
ParserPool parserPool1() {
    BasicParserPool pool = new BasicParserPool();
    pool.setIgnoreComments(true);
    return pool;
}
</code></pre>
</p>


<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://duo.com/blog/duo-finds-saml-vulnerabilities-affecting-multiple-implementations">Duo Finds SAML Vulnerabilities Affecting Multiple Implementations</a><br/>
<a target="_blank" href="https://spring.io/blog/2018/03/01/spring-security-saml-and-this-week-s-saml-vulnerability">Spring Security SAML and this week's SAML Vulnerability</a><br/>

</p>


            
        

        <hr/>
        <br/>
    </section>
    
    <section>
        <a class="anchor" name="OVERLY_PERMISSIVE_FILE_PERMISSION"></a>
        <h2 class="page-header">
            過剰に許可されたファイルパーミッション
            <a href="#OVERLY_PERMISSIVE_FILE_PERMISSION" title="Permanent link"><small><i class="fa fa-link"></i></small></a>
        </h2>
        <p class="text-muted"><em><small>Bug Pattern: <tt>OVERLY_PERMISSIVE_FILE_PERMISSION</tt></small></em></p>

        
            
<p>
一般に，すべてのユーザーに read+write+exec などの過剰に許可されたファイルパーミッションを設定することは悪い習慣です。
影響を受けるファイルが構成，バイナリ，スクリプト，または機密データである場合，権限昇格または情報漏洩につながる可能性があります。
</p>
<p>
アプリケーションと同じホストで実行されている別のサービスが危険にさらされる可能性があります。
通常，サービスは別のユーザーで実行されます。
侵害されたサービスアカウントは，構成の読み取り，スクリプトへの実行命令の追加，データファイルの変更に使用される可能性があります。
他のサービスやローカルユーザーからのダメージを制限するには，アプリケーションファイルのパーミッションに制限するべきです。
</p>

<p>
<b>脆弱なコード 1 (シンボリック表記):</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Files.setPosixFilePermissions(configPath, PosixFilePermissions.fromString("rw-rw-rw-"));
</code></pre>
</p>

<p>
<b>解決策 1 (シンボリック表記):</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Files.setPosixFilePermissions(configPath, PosixFilePermissions.fromString("rw-rw----"));
</code></pre>
</p>


<p>
<b>脆弱なコード 2 (オブジェクト指向実装):</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Set&lt;PosixFilePermission&gt; perms = new HashSet&lt;&gt;();
perms.add(PosixFilePermission.OWNER_READ);
perms.add(PosixFilePermission.OWNER_WRITE);
perms.add(PosixFilePermission.OWNER_EXECUTE);

perms.add(PosixFilePermission.GROUP_READ);
perms.add(PosixFilePermission.GROUP_WRITE);
perms.add(PosixFilePermission.GROUP_EXECUTE);

perms.add(PosixFilePermission.OTHERS_READ);
perms.add(PosixFilePermission.OTHERS_WRITE);
perms.add(PosixFilePermission.OTHERS_EXECUTE);
</code></pre>
</p>

<p>
<b>解決策 2 (オブジェクト指向実装):</b><br/>
<pre class='keep-initial-line-feed'><code class='code.language-java keep-initial-line-feed'>Set&lt;PosixFilePermission&gt; perms = new HashSet&lt;&gt;();
perms.add(PosixFilePermission.OWNER_READ);
perms.add(PosixFilePermission.OWNER_WRITE);
perms.add(PosixFilePermission.OWNER_EXECUTE);

perms.add(PosixFilePermission.GROUP_READ);
perms.add(PosixFilePermission.GROUP_WRITE);
perms.add(PosixFilePermission.GROUP_EXECUTE);
</code></pre>
</p>

<p>
<b>参考文献</b><br/>
<a target="_blank" href="https://cwe.mitre.org/data/definitions/732.html">CWE-732: Incorrect Permission Assignment for Critical Resource</a><br/>
<a target="_blank" href="https://payatu.com/guide-linux-privilege-escalation/">A guide to Linux Privilege Escalation</a><br/>
<a target="_blank" href="https://en.wikipedia.org/wiki/File_system_permissions">File system permissions</a><br/>
</p>

            
        

        <hr/>
        <br/>
    </section>
    
        </div>

        <div class="col-md-1" id="rightCol">

            <div  id="sidebar_lang">
                <h4>Languages:</h4>
                <ul class="nav nav-pills nav-stacked">
                    <li><a href="bugs.htm">English</a></li>
                    <li class="active"><a href="#">Japanese</a></li>
                </ul>
            </div>
        </div>
    </div>
</div>


<br/><br/>

<footer id="footer" class="footer hidden-print">
    <div class="container text-center">
        <div>
            Find Security Bugs 1.12.0
            <span class="hide-xs">&middot;</span>
            Created by <a target="_blank" href="https://twitter.com/h3xstream">Philippe Arteau</a>
        </div>
        <div>
            Licensed under <a href="license.htm">LGPL</a>
        </div>
    </div>
</footer>

<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>-->
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="js/jquery.min.js"></script>
<script src="js/bootstrap.min.js"></script>
<script src="js/fsb-custom.js"></script>
<script src="js/prism.js"></script>

<!-- Google Analytics -->
<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-34839255-2']);
    _gaq.push(['_trackPageview']);

    (function () {
        var ga = document.createElement('script');
        ga.type = 'text/javascript';
        ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(ga, s);
    })();
</script>
</body>
</html>
